/********
    *
    * Advantage:
    *
    * In the following, a (`t`, `c`, `n`)-attacker is an attacker `A` that runs in time at most `t`,
    * makes at most `c` challenge queries, and never produces a group with more than `n` members.
    * The attacker wins the CGKA security game if they correctly guesses the random bit `b` in
    * the end and the safety predicate `P` evaluates to true on the queries made by the attacker.
    *
    * Security game's parameters' valid ranges:
    *   - T <- [3, 254]
    *   - C <- [1,   T]
    *   - N <- [3, 254] 
    *
    * Hence we define our (`t`, `c` `n`) constants below:
    *
********/
#define C 3
#define N 6
#define T 8


/****
  *
  * Number of bits required to represent:
  *   - N + 1
  *   - T + 1
  *   - N + N - 1
  *
****/
#define N_BITS 4
#define T_BITS 4
#define X_BITS 5


/****
  *
  * Lookup table for TREE value derived from N:
  *   - [ 1,   1] ->   1
  *   - [ 2,   2] ->   3
  *   - [ 3,   4] ->   7
  *   - [ 5,   8] ->  15
  *   - [ 9,  16] ->  31
  *   - [17,  32] ->  63
  *   - [33,  64] -> 127
  *   - [65, 128] -> 255
  *
****/
#define TREE 15


/****
  *
  * Constants, respectively for the following:
  *   - Sentinal value for missing "user ID" data. Value should equal (2 ^ N_BITS - 1)
  *   - Sentinal value for missing "epoch  " data. Value should equal (2 ^ T_BITS - 1)
  *   - Index of the root node in the heap
  *   - Offset to index the first node of the heap
  *   - Final epoch of the security game with implicit "challenge"
  *   - Number of revelations the attacker may make during the game.
  *     Note that revelation moves require using a challenge and,
  *     because the last challenge must be saved to end the game,
  *     a revelation move cannot use the last available challenge.
  *
****/
#define NONE  ( N )
#define NEVER ( T )
#define ROOT 0
#define NODE (TREE / 2)
#define LAST_EPOCH (T - 1)
#define MAX_REVEAL (C - 1)


/****
  *
  * Global state of the CGKA security game.
  *
****/

local unsigned epoch     : T_BITS; // The current epoch
local unsigned unsafeIDs : N_BITS; // Number of unsafeIDs

local bool  challenge[T]; // Has the attacker challenged in an epoch?
local bool membership[N]; // Group membership of current epoch
local bool     unsafe[N]; // Members which require a change to update
local byte   hoarding[N]; // Epoch from which the user saves secrets

/****
  *
  * Global state of the attacker.
  *
****/

//        Void - This node does not exist  and there exists 0 leaves in the subtree
// UnknownRefs - This node does not exist  and there exists 1 leaf   in the subtree
//   KnownRefs - This node does not exist  and there exists 1 leaf   in the subtree
// UnknownNode - This node          exists and there exists 1 or more leaves in the subtree
//   KnownNode - This node          exists and there exists 1 or more leaves in the subtree
mtype:Secret = { Void, UnknownRefs, KnownRefs, UnknownNode, KnownNode };

// Required for a multidimensional array
typedef TreeKeys   { mtype:Secret node[ TREE ]  };
TreeKeys attackerKnowledge[T];

/****
  *
  * Left-balanced Binary Tree:
  *
  *            +-----(14)-----+
  *           /                \
  *         (12)              (13)
  *        /    \            /    \
  *     (8)     (9)       (10)     (11)
  *    /   \   /   \     /    \   /    \
  *   0     1 2     3   4      5 6      7 
  *
  * Binary Heap Layout:
  *
  * Index:   0   1   2   3   4   5   6   7   8   9  10  11  12  13  14
  * Array: [  ][  ][  ][  ][  ][  ][  ][  ][  ][  ][  ][  ][  ][  ][  ]
  * Node:   14  12  13   8   9  10  11   0   1   2   3   4   5   6   7
  *
****/

local bool attackerKnowsRootKey = false;


/****
  *
  * Global state of verifying used for LTL.
  *
****/

/********
    *
    * Saftey Predicate (Triviality):
    *
    * Consider the following succession of attacker moves in the CKGA game.
    * We will call each move a "query," as to remain in line with the literature.
    * The attacker performs a non-empty sequence of queries to the oracles.
    * The sequence then ends with an additional query to a special "challenge" oracle.
    * By construction the sequence has at least 2 queries.
    *
    * Consider the function
    *     whichEpoch(q) : query -> Natural
    * This function returns the epoch during which the query was made.
    *
    * Now consider the array `Q` containing the sequence of queries.
    *
    *     triviality ( Q ):
    *         for  (i,j) s.t. Q[i] = corrupt(ID) and Q[j] = challenge
    *             if
    *                 whichEpoch(Q[i]) <= whichEpoch(Q[j]) AND there does not exist `k` s.t.
    *                     0 < whichEpoch(Q[i]) < whichEpoch(Q[k]) <= whichEpoch(Q[j]) AND
    *                     Q[k] = update(ID) or Q[k] = remove(ID)
    *             then
    *                 return FALSE
    *             done
    *             if
    *                 which(Q[i]) > whichEpoch(Q[j]) AND there exists `k` s.t.
    *                   whichEpoch(Q[k]) <= whichEpoch(Q[j]) AND Q[k] = hoard(ID)
    *             then
    *                 return FALSE
    *             done
    *         end
    *         return TRUE
    *
    * This predicate is described as the "Safety Predicate" `safe` in Alwen 2020.
    * We use `triviality` as a synonym from `safe` because the term "safety predicate has
    * a different connotation in  formal methods nomenclature.
    *   
********/

/****
  * Does a trivial attack exist? i.e, does the SAFE predicate hold?
  *
  * SYNC: Updated by `post_move_poll`
****/
local bool triviality = false; 


/****
  * Has the CGKA game end?
  *
  * SYNC: Bit flipped IFF at the end of `init`
****/
local bool concludedCGKA = false;


/****
  *
  * Global state of derivative variables.
  *   (Each can is defined in terms of the CGKA global state variables)
  *
****/

// Group Composition
local unsigned attendees : N_BITS = N;
local unsigned absentees : N_BITS = 0;
local unsigned groupMost : N_BITS = 0; // The maximum member ID during any past/present epoch.
local bool     groupDyad          = false;
local bool     groupFull          = false;

// Protocol State
local bool forcedPlay = false;
local bool revealRoot = C > 1;


/********
    *
    * Global state priniting utilities:
    *
    *   - print_attacker_knowledge
    *   - print_challenges
    *   - print_group_composition
    *   - print_membership
    *   - print_protocol_state
    *   - print_user_hoarding
    *   - print_user_unsafe
    *
********/


inline print_attacker_knowledge()
{
    d_step
    {
        printf("\n\tAttacker Knowledge:");
        unsigned t : T_BITS;
        for( t : 0 .. T - 1 )
        {
            printf("\n>>> %d vvv", t);
            d_step
            {
                unsigned v : X_BITS;
                for( v : 0 .. TREE - 1 )
                {
                    if
                    :: attackerKnowledge[t].node[v] == UnknownRefs -> printf("\n\t%d [ x ]", v)
                    :: attackerKnowledge[t].node[v] == UnknownNode -> printf("\n\t%d [ X ]", v)
                    :: attackerKnowledge[t].node[v] ==   KnownRefs -> printf("\n\t%d [ o ]", v)
                    :: attackerKnowledge[t].node[v] ==   KnownNode -> printf("\n\t%d [ O ]", v)
                    :: attackerKnowledge[t].node[v] ==        Void -> printf("\n\t%d [   ]", v)
                    :: else                                        -> printf("\n\t%d [ ? ]", v)
                    fi
                }
            }
        };
        printf("\n");
    }
}


inline print_challenges()
{
    d_step {
        printf("\n\tChallenges:");
        unsigned t : T_BITS;
        for ( t : 0 .. T - 1)
        {
            if
            :: challenge[t] -> printf("\n\t    [\tTrue\t]");
            :: else         -> printf("\n\t    [\tFalse\t]");
            fi
        }
        printf("\n");
    }
}


inline print_group_composition()
{
    d_step
    {
        printf("\n\tattendees \t%d", attendees );
        printf("\n\tabsentees \t%d", absentees );
        printf("\n\tgroupDyad \t%d", groupDyad );
        printf("\n\tgroupFull \t%d", groupFull );
        printf("\n\tgroupMost \t%d", groupMost );
    }
}


inline print_membership()
{
    d_step {
        printf("\n\tMembership:");
        unsigned p : N_BITS;
        for( p : 0 .. N - 1 )
        {
            if
            :: membership[p] -> printf("\n\t    [\tTrue\t]");
            :: else          -> printf("\n\t    [\tFalse\t]");
            fi
        };
        printf("\n");
    }
}


inline print_protocol_state()
{
    d_step
    {
        printf("\n\trevealRoot \t%d", revealRoot );
        printf("\n\tforcedPlay \t%d", forcedPlay );
        printf("\n\tunsafeIDs  \t%d", unsafeIDs  );
    }
}


inline print_user_hoarding()
{
    d_step {
        printf("\n\tHoarding since:");
        unsigned p : N_BITS;
        for ( p : 0 .. N - 1)
        {
            if
            :: hoarding[p] == NONE -> printf("\n\t    [\tNONE\t]")
            :: else                -> printf("\n\t    [\t%d\t]", hoarding[p])
            fi
        }
        printf("\n");
    }
}


inline print_user_unsafe()
{
    d_step {
        printf("\n\tRequired healing:");
        unsigned p : N_BITS;
        for ( p : 0 .. N - 1)
        {
            if
            :: unsafe[p] -> printf("\n\t    [\tTrue\t]");
            :: else      -> printf("\n\t    [\tFalse\t]");
            fi
        }
        printf("\n");
    }
}


inline print_global_state()
{
    d_step
    {
        printf("\n-=-=-=-=-=-=-=-=-=-=-=-\n-=-  GLOBAL  STATE  -=-\n-=-=-=-=-=-=-=-=-=-=-=-\n");
        print_challenges();
        print_membership();
        print_user_hoarding();
        print_user_unsafe();
        print_group_composition();
        print_protocol_state();
        print_attacker_knowledge()
    }
}


/********
    *
    * Inline utilities for after move updates:
    *   - post_move_poll
    *   - take_attendance
    *
********/


/****
  * External result variable(s):
  *   - commitmentRequired
  *   - forcedPlay
  *   - revealRoot
  *   - triviality
  *   - unsafeIDs
****/
inline post_move_poll( e )
{
    d_step {
        // Refresh "unsafeIDs"
        unsigned remainingEpochs    : T_BITS = LAST_EPOCH - e;
        unsigned recoveriesRequired : N_BITS = 0;
        d_step
        {
            unsigned n : N_BITS;
            for ( n : 0 .. N - 1 ) {
                if
                :: unsafe[n] -> recoveriesRequired++;
                :: else
                fi
            }
        }
        unsafeIDs  = recoveriesRequired;

        // Refresh "triviality"
        triviality = unsafeIDs > 0; 

        // Refresh "forcedPlay"
        forcedPlay = unsafeIDs > 0 && unsafeIDs == remainingEpochs;
        printf("\n\tremainingEpochs\t%d\n\tunsafeIDs\t%d\n", remainingEpochs, unsafeIDs);

        // Refresh "revealRoot"
        revealRoot = !challenge[e] && (e != LAST_EPOCH) && attackerKnowledge[e].node[ROOT] == UnknownNode;
        if
        :: !revealRoot -> skip
        :: else ->
            unsigned challengesUsed : T_BITS = 0;
            d_step
            {
                unsigned n : N_BITS;
                for ( n : 0 .. e )
                {
                    if
                    :: challenge[n] -> challengesUsed++;
                    :: else
                    fi
                }
            };
            revealRoot = challengesUsed < MAX_REVEAL;
        fi

        // Refresh "commitmentRequired"
        bool canHoardMember = false;
        d_step
        {
            unsigned candidateHoarders : N_BITS;
            candidates_for_hoarding();
            canHoardMember = candidateHoarders > 0;
    //        printf("\n canHoardMember = %d", canHoardMember);
        }
    
        bool canCorruptMember = false;
        d_step
        {
            unsigned candidateCorruptibles : N_BITS;
            candidates_for_corruption();
            canCorruptMember = candidateCorruptibles > 0;
    //        printf("\n canCorruptMember = %d", canCorruptMember);
        }
    
        commitmentRequired = !revealRoot && !canHoardMember && !canCorruptMember
    }
}


/****
  * External result variable(s):
  *   - absentees
  *   - attendees
  *   - groupDyad
  *   - groupFull
  *   - groupMost
****/
inline take_attendance()
{
    unsigned largestID : N_BITS;
    d_step {
        unsigned included : N_BITS = 0;
        d_step {
            unsigned n : N_BITS;
            for ( n : 0 .. N - 1 ) {
                 if
                 :: membership[n] -> included++; largestID = n
                 :: else
                 fi
            }
        }
        attendees = included;
        absentees = N - attendees;
        groupDyad = attendees == 2;
        groupFull = absentees == 0;
    }

    if
    :: largestID + 1 > groupMost -> groupMost = largestID + 1;
    :: else
    fi

    d_step
    {
        printf("\n\tattendees \t%d", attendees );
        printf("\n\tabsentees \t%d", absentees );
        printf("\n\tgroupDyad \t%d", groupDyad );
        printf("\n\tgroupFull \t%d", groupFull );
        printf("\n\tgroupMost \t%d", groupMost );
    }
}


/********
    *
    * User ID selection inlines:
    *   - select_corrupted
    *   - select_banisher
    *   - select_exiled
    *   - select_hoarder
    *   - select_joiner
    *   - select_sender
    *   - select_updater
    *
********/


/****
  * External result variable(s):
  *   - corruptedID
****/
inline select_corrupted()
{   atomic {

    unsigned candidateCorruptibles : N_BITS;
    candidates_for_corruption();
    if
    :: candidateCorruptibles == 0 -> corruptedID = NONE
    :: else ->
        unsigned selection : N_BITS = NONE;
        d_step
        {
            unsigned n      : N_BITS;
            unsigned sample : N_BITS;
            select ( sample : 0 .. candidateCorruptibles - 1 );
            for ( n : 0 .. N )
            {
                d_step
                {
                    if
                    :: selection == NONE ->
                        bool candidateCorruption;
                        candidate_corruption( n );
                        if
                        :: candidateCorruption ->
                            if
                            :: sample == 0 -> selection = n
                            :: sample != 0 -> sample--
                            fi
                        :: else
                        fi
                    :: else
                    fi
                }
            }
        }
        corruptedID = selection
    fi
}   }


/****
  * External result variable(s):
  *   - candidateCorruptibles
****/
inline candidates_for_corruption()
{
    unsigned remaining : T_BITS = LAST_EPOCH - epoch;

    if
    :: unsafeIDs >= remaining -> candidateCorruptibles = 0;
    :: else ->
        unsigned candidates : N_BITS = 0;
        d_step
        {
            unsigned n : N_BITS;
            for ( n : 0 .. N - 1 )
            {
                bool candidateCorruption;
                candidate_corruption( n );
                if
                :: candidateCorruption -> candidates++
                :: else
                fi
            }
        }
        candidateCorruptibles = candidates
    fi
}


/****
  * External result variable(s):
  *   - candidateCorruption
****/
inline candidate_corruption( id )
{
    // The corrupted user must not previously been instructed to hoard!
    // Violates the "Safety Predicate SAFE" described in Alwen 2020.
    candidateCorruption = hoarding[id] == NONE && membership[id] && attackerKnowledge[epoch].node[NODE+id] == UnknownNode
}


/****
  * External result variable(s):
  *   - banisherID
****/
inline select_banisher( banned )
{
    unsigned selectedID : N_BITS;
    select_sender_constrained( banned, false );
    banisherID = selectedID;
}


/****
  * External result variable(s):
  *   - exiledID
****/
inline select_exiled( forced )
{
    unsigned selectedID : N_BITS;
    select_sender_constrained( NONE, forced );
    exiledID = selectedID;
}


/****
  * External result variable(s):
  *   - hoarderID
****/
inline select_hoarder()
{   atomic {

    unsigned candidateHoarders : N_BITS;
    candidates_for_hoarding();

    if
    :: candidateHoarders == 0 -> hoarderID = NONE
    :: else ->
        unsigned selection : N_BITS = NONE;
        d_step
        {
            unsigned n      : N_BITS;
            unsigned sample : N_BITS;
            select ( sample : 0 .. candidateHoarders - 1 );
            for ( n : 0 .. N - 1 )
            {
                d_step
                {
                    if
                    :: selection != NONE -> skip
                    :: else ->
                        bool candidateHoarder
                        candidate_hoarder( n );
                        if
                        :: !(candidateHoarder) -> skip
                        :: else ->
                            if
                            :: sample == 0 -> selection = n
                            :: sample != 0 -> sample--
                            fi
                        fi
                    fi
                }
            }
        }
        hoarderID = selection
    fi
}   }


/****
  * External result variable(s):
  *   - candidateHoarders
****/
inline candidates_for_hoarding()
{
    unsigned candidates : N_BITS = 0;
    d_step
    {
        unsigned n : N_BITS;
        for ( n : 0 .. N - 1 )
        {
            bool candidateHoarder
            candidate_hoarder( n );
            if
            :: candidateHoarder -> candidates++
            :: else
            fi
        }
    }
    candidateHoarders = candidates
}


/****
  * External result variable(s):
  *   - candidateHoarder
****/
inline candidate_hoarder( id )
{
    candidateHoarder = hoarding[id] == NONE && membership[id]
}


/****
  * External result variable(s):
  *   - joinerID
****/
inline select_joiner()
{   atomic {

    unsigned candidateJoiners : N_BITS;
    candidates_for_joiner();

    unsigned selection : N_BITS = NONE;
    d_step
    {
        unsigned n      : N_BITS;
        unsigned sample : N_BITS;
        select(  sample : 0 .. candidateJoiners - 1 );
        for ( n : 0 .. N - 1 ) {
            if
            :: selection != NONE || membership[n] -> skip
            :: else ->
                if
                :: sample != 0 -> sample--
                :: sample == 0 -> selection = n
                fi
            fi
        }
    }
    
    joinerID = selection;
}   }


/****
  * External result variable(s):
  *   - candidateJoiners
****/
inline candidates_for_joiner()
{
    unsigned candidates : N_BITS = 0;
    d_step
    {
        unsigned n : N_BITS;
        for ( n : 0 .. groupMost - 1 )
        {
            if
            :: !(membership[n]) -> candidates++
            :: else
            fi
        }
    }

    // Consider adding the next user who has never been a member before...
    // but make the consideration *if and only if* such a user exists.
    d_step
    {
        if
        :: groupMost == N -> skip
        :: else -> candidates++
        fi
    }
    candidateJoiners = candidates
}


/****
  * External result variable(s):
  *   - senderID
****/
inline select_sender()
{
    unsigned selectedID : N_BITS;
    select_sender_constrained( NONE, false );
    senderID = selectedID;
}


/****
  * External result variable(s):
  *   - updaterID
****/
inline select_updater( forced )
{
    unsigned selectedID : N_BITS;
    select_sender_constrained( NONE, forced );
    updaterID = selectedID;
}


/****
  * External result variable(s):
  *   - selectedID
****/
inline select_sender_constrained ( banned, forced )
{   atomic {
    unsigned candidates : N_BITS = 0;

    d_step
    {
        unsigned n : N_BITS;
        for ( n : 0 .. N - 1 )
        {
            bool senderCandidate;
            sender_candidate( banned, forced, n );
            if
            :: senderCandidate -> candidates++
            :: else
            fi
        }
    }

    if
    :: candidates == 0 -> selectedID = NONE
    :: else ->
        unsigned selection : N_BITS = NONE;
        d_step
        {
            unsigned n      : N_BITS;
            unsigned sample : N_BITS;
            select(  sample : 0 .. candidates - 1 );
            for ( n : 0 .. N - 1 ) {
                d_step
                {
                    if
                    :: selection == NONE ->
                        bool senderCandidate;
                        sender_candidate( banned, forced, n );
                        if
                        :: senderCandidate ->
                            if
                            :: sample == 0 -> selection = n
                            :: sample != 0 -> sample--
                            fi
                        :: else
                        fi
                    :: else
                    fi
                }
            }
        }
        selectedID = selection;
    fi
}   }


/****
  * External result variable(s):
  *   - senderCandidate
****/
inline sender_candidate( banned, forced, id )
{
//    bool querryOkay = commitment || !(epochQuerried[id]);
//    bool forcesSafe = (!(forced) && querryOkay) || unsafe[id];
    bool forcesSafe = !(forced)  || unsafe[id];
    bool isAnOption = membership[id] && (id != banned);
    senderCandidate = isAnOption && forcesSafe
}


/****
  *
  * The following methods:
  *   - broadcast
  *   - propogate
  *
  * Are used by the security game moves:
  *   - insert_member
  *   - remove_member
  *   - oblige_update
  *
****/


inline broadcast ( e, sender, subject )
{
    attacker_observes_message( e, sender, subject );
}


inline propogate ( sender, insert, remove )
{
    d_step {
        if
        :: insert != NONE -> membership[insert] = true
        :: remove != NONE -> membership[remove] = false
        :: else
        fi

        take_attendance();
    }
}


/****
  *
  * The following methods:
  *   - attacker_initializes_knowledge
  *   - attacker_insight_check
  *   - attacker_observes_message
  *
  * Are used by the security game moves:
  *   - broadcast
  *   - CGKA_initialize
  *   - corrupt
  *
****/


inline attacker_initializes_knowledge()
{
    d_step
    {
        unsigned t : T_BITS;
        for( t : 0 .. T - 1 )
        {
            unsigned v : X_BITS
            for( v : 0 .. TREE - 1 )
            {
                attackerKnowledge[t].node[v] = Void
            }
        }
        attackerKnowsRootKey = false;
    }
}


inline attacker_observes_message( e, sender, subject )
{
    atomic
    {
        // If the attacker has know knowledge of the epoch,
        // meaning that all cell values are "Void,"
        // then it is the first time we have entered the epoch
        // and the cell values should be initialized as either:
        //   * UnknownNode
        //   * UnknownRefs
        //   *        Void
        bool noEpochKnowledge;
        attacker_has_no_epoch_knowledge( e );
        if
        :: noEpochKnowledge -> attacker_init_epoch_knowledge( e );
        :: else
        fi
        
        //       referenceEpoch = (e == 0) ? e : e - 1;
        unsigned referenceEpoch : T_BITS = e ;
        if
        :: e != 0 -> referenceEpoch--;
        :: else
        fi

        attacker_copy_epoch_knowledge( referenceEpoch );
        attacker_wipe_sender_knowledge( sender, e );
        attacker_updates_knowledge ( e );
        attacker_insight_check( e );
    }
}

inline attacker_insight_check( e )
{
    bool anyRootKnown = false;
    d_step
    {
        unsigned t : T_BITS;
        for( t : 0 .. e )
        {
            anyRootKnown = anyRootKnown || attackerKnowledge[t].node[ROOT]
        }
    }
    attackerKnowsRootKey = anyRootKnown;
}


inline attacker_has_no_epoch_knowledge ( e )
{
    d_step
    {
        bool allVoid = true;
        unsigned v : X_BITS;
        for ( v : 0 .. TREE - 1 )
        {
            allVoid = allVoid && (attackerKnowledge[e].node[v] == Void)
        }
        noEpochKnowledge = allVoid;
    }
}


inline attacker_init_epoch_knowledge( e )
{   atomic {

    bool leaves = true;
    unsigned offset : X_BITS = NODE;
    unsigned width  : X_BITS = N + N;
    do
    :: width == 0 -> break
    :: width != 0 -> d_step
        {
            width = width / 2;
            unsigned n : X_BITS;
            for ( n : 0 .. width - 1 )
            {
                unsigned v : X_BITS = offset + n;
                // Leaf node case(s)
                if
                :: leaves ->
                    if
                    // No knowledge from excluded group members
                    :: !(membership[n]) -> attackerKnowledge[e].node[v] = Void
                    :: else             -> attackerKnowledge[e].node[v] = UnknownNode
                    fi
                // Internal node case(s)
                :: else ->
                    bool voidL, voidR;
                    d_step
                    {
                        unsigned childL : X_BITS = v * 2 + 1;
                        unsigned childR : X_BITS = v * 2 + 2;
                        // Check current epoch for existance of subtrees
                        bool existanceOfSubtree;
                        existance_of_subtree( e, childL);
                        voidL = !existanceOfSubtree;
                        existance_of_subtree( e, childR);
                        voidR = !existanceOfSubtree;
                    }
                    if
                    ::  voidL &&  voidR -> attackerKnowledge[e].node[v] =        Void
                    :: !voidL &&  voidR -> attackerKnowledge[e].node[v] = UnknownRefs
                    ::  voidL && !voidR -> attackerKnowledge[e].node[v] = UnknownRefs
                    :: !voidL && !voidR -> attackerKnowledge[e].node[v] = UnknownNode
                    fi
                fi
            };
            offset = offset / 2;
            leaves = false;
        }
    od
}   }


inline attacker_copy_epoch_knowledge( e )
{   atomic {

    unsigned offset : X_BITS = NODE;
    unsigned width  : X_BITS = TREE + 1;
    do
    :: width == 0 -> break
    :: width != 0 -> d_step
        {
            width = width / 2;
            unsigned n : X_BITS;
            for ( n : 0 .. width - 1 )
            {
                unsigned v : X_BITS = offset + n;
                bool knowledgeOfSubtree;
                knowledge_of_subtree( e, v);
                if
                ::  attackerKnowledge[e+1].node[v] == UnknownNode && knowledgeOfSubtree ->
                    attackerKnowledge[e+1].node[v] = KnownNode
                ::  attackerKnowledge[e+1].node[v] == UnknownRefs && knowledgeOfSubtree ->
                    attackerKnowledge[e+1].node[v] = KnownRefs
                :: else
                fi
            };
            offset = offset / 2;
        }
    od
}   }


inline attacker_wipe_sender_knowledge( sender, e )
{   atomic {

    unsigned offset : X_BITS = NODE;
    unsigned width  : X_BITS = TREE + 1;
    do
    :: width == 0 -> break
    :: width != 0 -> d_step
        {
            width = width / 2;
            unsigned v : X_BITS = offset + sender;
            if
            ::  attackerKnowledge[e].node[v] == UnknownNode ||
                attackerKnowledge[e].node[v] ==   KnownNode ->
                attackerKnowledge[e].node[v] =  UnknownNode
            ::  attackerKnowledge[e].node[v] == UnknownRefs ||
                attackerKnowledge[e].node[v] ==   KnownRefs ->
                attackerKnowledge[e].node[v] =  UnknownRefs
            :: else
            fi
            offset = offset / 2;
        }
    od
}   }


inline attacker_updates_knowledge( e )
{   atomic {

    bool     leaves = true;
    unsigned offset : X_BITS = NODE;
    unsigned width  : X_BITS = TREE + 1;
    do
    :: width == 0 -> break
    :: width != 0 -> d_step
        {
            width = width / 2;
            unsigned n : X_BITS;
            for ( n : 0 .. width - 1 )
            {
                unsigned v : X_BITS = offset + n;
                if
                :: leaves -> skip
                :: else ->
                    bool knowsL, knowsR, voidL, voidR;
                    d_step
                    {
                        unsigned childL : X_BITS = v * 2 + 1;
                        unsigned childR : X_BITS = v * 2 + 2;

                        // Check current epoch for existance of subtrees
                        bool existanceOfSubtree;
                        existance_of_subtree( e, childL);
                        voidL = !existanceOfSubtree;
                        existance_of_subtree( e, childR);
                        voidR = !existanceOfSubtree;
                        
                        // Check previous epoch for knowledge of subtrees
                        bool knowledgeOfSubtree;
                        knowledge_of_subtree( e, childL);
                        knowsL = knowledgeOfSubtree;
                        knowledge_of_subtree( e, childR);
                        knowsR = knowledgeOfSubtree;
                    }
                    if
                    ::  voidL &&  voidR                       -> attackerKnowledge[e].node[v] =        Void
                    :: !voidL &&  voidR &&             knowsR -> attackerKnowledge[e].node[v] =   KnownRefs
                    :: !voidL &&  voidR &&            !knowsR -> attackerKnowledge[e].node[v] = UnknownRefs
                    ::  voidL && !voidR &&  knowsL            -> attackerKnowledge[e].node[v] =   KnownRefs
                    ::  voidL && !voidR && !knowsL            -> attackerKnowledge[e].node[v] = UnknownRefs
                    :: !voidL && !voidR &&  knowsL &&  knowsR -> attackerKnowledge[e].node[v] =   KnownNode
                    :: !voidL && !voidR && !knowsL &&  knowsR -> attackerKnowledge[e].node[v] =   KnownNode
                    :: !voidL && !voidR &&  knowsL && !knowsR -> attackerKnowledge[e].node[v] =   KnownNode
                    :: !voidL && !voidR && !knowsL && !knowsR -> attackerKnowledge[e].node[v] = UnknownNode
                    fi
                fi
            };
            offset = offset / 2;
            leaves = false;
        }
    od
    }
}


inline existance_of_subtree( t, v )
{
    existanceOfSubtree = attackerKnowledge[t].node[v] != Void
}


inline knowledge_of_subtree( t, v )
{
    knowledgeOfSubtree = attackerKnowledge[t].node[v] == KnownNode || attackerKnowledge[t].node[v] == KnownRefs
}


/********
    *
    * Oracles available to the attacker:
    *
    *   - Corrupt
    *   - Hoard
    *   - Reveal
    *
********/


inline corrupt( memberID )
{   atomic {

    printf("\n> > >\n> CGKA: Game Move = COR %d\n> > >\n", memberID);

    // Learn the secret material of the user in their current epoch
    unsigned upperBound : T_BITS = epoch;
    unsigned lowerBound : T_BITS = upperBound;

    // Learn any additional secrets they have hoarded!
    unsigned epochSavedFrom : T_BITS = hoarding[memberID];
    if
    :: epochSavedFrom < upperBound -> lowerBound = epochSavedFrom
    :: else
    fi

    printf("Corrupting from: %d -- %d\n", lowerBound, upperBound);

    // For each epoch which the member has secrets
    // (this implies that the user was a member)
    // Then the attacker learns the secrets on the direct path
    // between the member and the root node on the LBBT.
    unsigned peek : T_BITS;
    for ( peek : lowerBound .. upperBound )
    {
        if
        :: !(membership[memberID]) -> skip
        :: else ->
            printf("Passed membership guard!\n");
            unsigned off   : X_BITS = NODE;
            unsigned level : X_BITS = TREE + 1;
            do
            :: level == 0 -> break
            :: level != 0 ->
                d_step
                {
                    level = level / 2;
                    unsigned v : X_BITS = off+memberID;
                    printf("tree level: %d @ %d\n", level, v);
                    if
                    :: attackerKnowledge[peek].node[v] == UnknownNode -> attackerKnowledge[peek].node[v] = KnownNode
                    :: attackerKnowledge[peek].node[v] == UnknownRefs -> attackerKnowledge[peek].node[v] = KnownRefs
                    :: else
                    fi
                    off = off / 2;
                }
                printf("Check Index Post: %d\n", peek);
                if
                :: peek == upperBound ->
                    printf("UPPER BOUNDed %d\n", peek);
                    attacker_updates_knowledge( peek );
                :: else ->
                    printf("Lower Pre %d\n", peek);
                    attacker_copy_epoch_knowledge( peek  );
                    printf("Lower Post %d\n", peek);
                    attacker_updates_knowledge(   peek+1 );
                fi
                printf("Before hand off: %d\n", peek);
            od
        fi
    }
    attacker_insight_check( epoch );
    unsafe[memberID] = true;
}   }


inline hoard( memberID )
{
    d_step {
        printf("\n> > >\n> CGKA: Game Move = HOD %d\n> > >\n", memberID);
        hoarding[memberID] = epoch
    }
}


inline reveal()
{
    d_step {
        printf("\n> > >\n> CGKA: Game Move = RVL %d\n> > >\n", epoch);
        challenge[epoch] = true;
        attackerKnowledge[epoch].node[ROOT] -> KnownNode;
    }
}


/********
    *
    * Oracles available to the Group Members:
    *
    *   - Insert Member ( ADD )
    *   - Remove Member ( RMV )
    *   - Oblige Update ( UPD )
    *
********/


// Precondition: joiner is not in the group!
inline insert_member( sender, joiner )
{
    d_step {
        printf("\n> > >\n> CGKA: Game Move = ADD %d %d\n> > >\n", sender, joiner);
        assert(sender < N);
        assert(joiner < N);
        propogate( sender, joiner, NONE );
    }
    broadcast( epoch + 1, sender, joiner );
}


// Precondition: exiledMemeber is in the group!
inline remove_member( sender, exiled )
{
    d_step {
        printf("\n> > >\n> CGKA: Game Move = RMV %d %d\n> > >\n", sender, exiled);
        assert(sender < N);
        assert(exiled < N);
        unsafe[exiled] = false;
        propogate( sender, NONE, exiled);
    }
    broadcast( epoch + 1, sender, exiled );
}


inline oblige_update( sender )
{
    d_step {
        printf("\n> > >\n> CGKA: Game Move = UPD %d\n> > >\n", sender);
        assert(sender < N);
        unsafe[sender] = false;
        propogate( sender, NONE, NONE );
    }
    broadcast( epoch + 1, sender, NONE );
}


/********
    *
    * Attacker moves interacting with oracles:
    *
    *   - play_move_with_commitment
    *   - play_move_without_commitment
    *
********/


inline play_move_with_commitment()
{
    unsigned exiledID : N_BITS, banisherID : N_BITS, updaterID : N_BITS;
    
    atomic
    {
        select_updater(  forcedPlay );
        select_exiled(   forcedPlay );
        select_banisher( exiledID   );
    };

    d_step
    {
        printf("\nEpoch (t) = %d\n", epoch );
        print_global_state()
        printf("\n\texiledID    \t%d",   exiledID );
        printf("\n\tbanisherID  \t%d", banisherID );
        printf("\n\tupdaterID   \t%d",  updaterID );
        printf("\nCOMMITTING!\n");
    }

    do
    // Update
    :: updaterID != NONE ->
        oblige_update( updaterID ); break

    // Remove
    :: !groupDyad && exiledID != NONE && banisherID != NONE ->
        remove_member( banisherID, exiledID ); break

    // Insert
    :: !groupFull && !forcedPlay -> atomic
        {
            unsigned joinerID : N_BITS, senderID : N_BITS;
            select_sender();
            select_joiner();
            insert_member( senderID, joinerID );
        }; break
    od

    post_move_poll( epoch + 1);
}


/****
  *
  * Attacker moves without advancing the epoch via one of the following oracles:
  *
  *   - Corrupt
  *   - Hoard
  *   - Reveal
  *
****/
inline play_move_without_commitment()
{   atomic
    {
        unsigned corruptedID : N_BITS, hoarderID : N_BITS;
    
        atomic
        {
            select_corrupted();
            select_hoarder();
        };
    
        d_step
        {
            printf("\nEpoch (t) = %d\n", epoch);
            print_global_state()
            printf("\n\tcanRevealKey\t%d",  revealRoot );
            printf("\n\tcorruptedID \t%d", corruptedID );
            printf("\n\thoarderID   \t%d",   hoarderID );
            printf("\nNON-Committal!\n");
        }

        do
        :: corruptedID != NONE && !forcedPlay -> corrupt( corruptedID ); break
        :: hoarderID   != NONE                -> hoard(     hoarderID ); break
        :: revealRoot                         -> reveal(              ); break
        od
    
        post_move_poll( epoch );
    }
}


/********
    *
    * Initialization inline routines, in order of execution:
    *
    *   - Initialize
    *   - Select Group
    *   - Create Group
    *   - CGKA Security Game
    *
********/


inline CGKA_initialize()
{   atomic {
    d_step
    {
        printf("\n***********************\n* CGKA: Initialize!   *\n***********************\n");

        d_step
        {
            unsigned n : N_BITS;
            for( n : 0 .. N - 1 )
            {
                hoarding[n]  = NEVER;
            };
        };
        
        d_step
        {
            unsigned t : T_BITS;
            for( t : 0 .. T - 1 )
            {
                challenge[t] = false;
            };
        };

        epoch     = 0;
        unsafeIDs = 0;
        
        concludedCGKA = false;
        triviality    = false; 

        attacker_initializes_knowledge()
    };

}   }


inline CGKA_create_group()
{
    // Number of members to add
    unsigned sample : N_BITS;
    d_step {
        select ( sample : 2 .. N );
        unsigned n      : N_BITS;
        for( n : 0 .. N - 1 )
        {
            membership[n] = n < sample;
        };
    }
    printf("\n***********************\n* CGKA: Create Group! *\n***********************\n");

    // Set the "lead" byte to be the first member in the group.
    d_step {
        unsigned id0 : N_BITS = 0;
        unsigned ep0 : T_BITS = 0;
        propogate ( id0, NONE, NONE );
        broadcast ( ep0,  id0, NONE );
    }
    print_membership();
}


inline CGKA_security_game()
{
    printf("\n***********************\n* CGKA: Begin Play!   *\n***********************\n");


    // Each time the attacker takes a turn, they must decide whether or not to:
    //
    //   1. End the game; under the assumption that the attacker has won.
    //   2. Play a move which will *commit* the group members to advance to the next epoch
    //   3. Play a move which where the group members remain in the current epoch
    //
    // We call selection the options "challenge," "commitment," and "non-committal" moves, respectively.
    //
    // NOTE: option (1), is implicitly the last move in the model

    bool commitmentRequired = false;

    // Loop through all epochs
    for ( epoch : 0 .. LAST_EPOCH)
    {

        do
        // 1. Play the Challenge Move
        //     The attacker ending the game is implicitly the last move of the model
        //     so it always happens in the last epoch.
        :: epoch == LAST_EPOCH -> break
        
        // 2. Play a Commitment Move
        //     The attacker *may* play a move which commits to a new epoch...
        //     unless it is the last epoch.
        :: epoch != LAST_EPOCH -> play_move_with_commitment(); break
        
        // 3. Play a Non-commital Move
        //     The attacker *may* play a move and remain in the same epoch...
        //     unless the attacker has exhausted all indempotent non-comittal moves!
        :: !(commitmentRequired) -> play_move_without_commitment()
        od;

        // After the operation is complete, check to see if the an endgame condition has been reached.
        printf("\nLOOP broken: %d", epoch);
        printf ("\n< < <\n< Moves:   %d\n< Unsafe:  %d\n< < < \n", LAST_EPOCH - epoch, unsafeIDs);
    }
    epoch = LAST_EPOCH;
    print_global_state();
}


init
{
    CGKA_initialize();
    CGKA_create_group();
    CGKA_security_game();
    concludedCGKA = true;
}

ltl challenge      { []( (concludedCGKA && !triviality) -> attackerKnowledge[epoch].node[ROOT] != KnownNode) }
//ltl trivial_safety { []( (triviality && epoch <= LAST_EPOCH) -> attackerKnowledge[epoch].node[ROOT] != KnownNode) }
//ltl game_totality  { <>concludedCGKA }
//ltl attendees_more_than_one { [](attendees > 1) }
//ltl attendees_absentees_sum { [](attendees + absentees == N) }
