/********
    *
    * Advantage:
    *
    * In the following, a (`t`, `c`, `n`)-attacker is an attacker `A` that runs in time at most `t`,
    * makes at most `c` challenge queries, and never produces a group with more than `n` members.
    * The attacker wins the CGKA security game if they correctly guesses the random bit `b` in
    * the end and the safety predicate `P` evaluates to true on the queries made by the attacker.
    *
    * Hence we define our (`t`, `c` `n`) constants below:
    *
********/

// A constant for missing data
#define NONE 255

/****
  *
  * Security game's parameters' valid ranges:
  *   - T <- [3, 255]
  *   - C <- [1,   T]
  *   - N <- [3, 127]
  *
  * Lookup table for TREE value derived from N:
  *   - [ 1,   1] ->   1
  *   - [ 2,   2] ->   3
  *   - [ 3,   4] ->   7
  *   - [ 5,   8] ->  15
  *   - [ 9,  16] ->  31
  *   - [17,  32] ->  63
  *   - [33,  64] -> 127
  *   - [65, 128] -> 255
  *
****/
#define T    3
#define C    3
#define N    4
#define TREE 7
#define ROOT (TREE - 1)


/****
  *
  * Special types required for the protocol.
  *
****/


//        Void - This node does not exist  and there exists 0 leaves in the subtree
// UnknownRefs - This node does not exist  and there exists 1 leaf   in the subtree
//   KnownRefs - This node does not exist  and there exists 1 leaf   in the subtree
// UnknownNode - This node          exists and there exists 1 or more leaves in the subtree
//   KnownNode - This node          exists and there exists 1 or more leaves in the subtree
mtype:Secret = { Void, UnknownRefs, KnownRefs, UnknownNode, KnownNode };

mtype:Message = { ADD, RMV, UPD };

//typedef Group      { bool         membership[N] };
//typedef Enigma     { mtype:Secret secret[T]     };
typedef TreeKeys   { mtype:Secret node[ TREE ]  };


/****
  *
  * Global state of the CGKA security game.
  *
****/

//byte leadership[T]; // Who initiated the epoch?
bool  challenge[T]; // Has the attacker challenged in an epoch?

bool membership[N]; // Group membership of current epoch
//bool      epoch[N]; // Is each user part of
byte   hoarding[N]; // Epoch from which the user saves secrets
bool     unsafe[N]; // Members which require a change to update
bool epochQuerried[N]; 

// Epoch, Sender
// chan M[N] = [2] of { byte, byte };

TreeKeys attackerKnowledge[T];


/****
  *
  * Global (local) variable for inline functions.
  *
****/

local byte i = 0
local byte j = 0;
local byte t = 0;
local byte absentees = 0;
local byte attendees = N;
local byte unsafeIDs = 0;


bool finishedLoop = false;

/********
    *
    * Global state priniting utilities:
    *
    *   - print_challenges
    *   - print_leadership
    *   - print_membership
    *
********/


inline print_challenges()
{
    d_step {
        printf("\n\tChallenges:");
        for ( i : 0 .. T - 1)
        {
            if
            :: challenge[i] -> printf("\n\t    [\tTrue\t]");
            :: else     -> printf("\n\t    [\tFalse\t]");
            fi
        }
        printf("\n");
    }
}


/*
inline print_leadership()
{
    d_step {
        printf("\n\tLeadership:");
        for ( i : 0 .. T - 1)
        {
            if
            :: leadership[i] == NONE -> printf("\n\t    [\tNONE\t]")
            :: else            -> printf("\n\t    [\t%d\t]", leadership[i])
            fi
        }
        printf("\n");
    }
}
*/


inline print_membership()
{
    d_step {
        printf("\n\tMembership:");
        for( i : 0 .. N - 1 )
        {
            if
            :: membership[i] -> printf("\n\t    [\tTrue\t]");
            :: else          -> printf("\n\t    [\tFalse\t]");
            fi
        };
        printf("\n");
    }
}


inline print_epochQuerried()
{
    d_step {
        printf("\n\tEpochQuerried");
        for( i : 0 .. N - 1 )
        {
            if
            :: epochQuerried[i] -> printf("\n\t    [\tTrue\t]");
            :: else          -> printf("\n\t    [\tFalse\t]");
            fi
        };
        printf("\n");
    }
}


inline print_user_epochs()
{
    d_step {
        printf("\n\tEpoch observing:");
        for ( i : 0 .. N - 1)
        {
            if
            :: epoch[i] == NONE -> printf("\n\t    [\tNONE\t]")
            :: else          -> printf("\n\t    [\t%d\t]", epoch[i])
            fi
        }
        printf("\n");
    }
}


inline print_user_hoarding()
{
    d_step {
        printf("\n\tHoarding since:");
        for ( i : 0 .. N - 1)
        {
            if
            :: hoarding[i] == NONE -> printf("\n\t    [\tNONE\t]")
            :: else                -> printf("\n\t    [\t%d\t]", hoarding[i])
            fi
        }
        printf("\n");
    }
}


inline print_user_unsafe()
{
    d_step {
        printf("\n\tRequired healing:");
        for ( i : 0 .. N - 1)
        {
            if
            :: unsafe[i] -> printf("\n\t    [\tTrue\t]");
            :: else      -> printf("\n\t    [\tFalse\t]");
            fi
        }
        printf("\n");
    }
}


/*
inline print_user_messages()
{
    d_step {
        printf("\n\tMessages available:");
        for ( i : 0 .. N - 1)
        {
            if
            :: nempty( M[i] ) -> printf("\n\t    [\tTrue\t]");
            ::  empty( M[i] ) -> printf("\n\t    [\tFalse\t]");
            fi
        }
        printf("\n");
    }
}
*/

inline print_global_state()
{
    d_step
    {
        printf("\n-=-=-=-=-=-=-=-=-=-=-=-\n-=-  GLOBAL  STATE  -=-\n-=-=-=-=-=-=-=-=-=-=-=-\n");
        print_challenges()
//        print_leadership()
        print_membership()
        print_epochQuerried()
//        print_user_epochs()
        print_user_hoarding()
//        print_user_messages()
        print_user_unsafe()
    }
}

/********
    *
    * Inline utilities:
    *
    *   - Select Attendee
    *   - Select Absentee
    *   - Select byte
    *
********/


/****
  * External result variable(s):
  *   - groupFull
****/
inline group_full( input )
{   d_step {

    take_attendance( input )
    groupFull = absentees == 0;

}   }


/****
  * External result variable(s):
  *   - groupDyad
****/
inline group_dyad( input )
{   d_step {

    take_attendance( input )
    groupDyad = attendees == 2;

}   }


/*
/****
  * External result variable(s):
  *   - queueFull
****/
inline queue_full()
{   d_step {

    bool found = false
    for( i : 0 .. N - 1 )
    {
        if
        :: full( M[i] ) -> found = true
        :: else
        fi
    }

}   }
*/


/****
  * External result variable(s):
  *   - unsafeIDs
****/
inline safety_poll()
{
    d_step {
        byte recoveriesRequired = 0;
        for ( i : 0 .. N - 1 ) {
            if
            :: unsafe[i] -> recoveriesRequired++;
            :: else
            fi
        }
        unsafeIDs = recoveriesRequired;
    }
}


/****
  * External result variable(s):
  *   - absentees
  *   - attendees
****/
inline take_attendance( t )
{   d_step {

    byte included = 0;
    for ( i : 0 .. N - 1 ) {
         if
         :: membership[i] -> included++
         :: else
         fi
    }
    attendees = included;
    absentees = N - attendees;

}   }


/****
  * External result variable(s):
  *   - selectedID
****/
inline select_attendee( t )
{   atomic {

    byte bound, sample;
    byte selection = NONE;

    take_attendance( t );
    select( sample : 0 .. attendees - 1 );

/*
    printf("\nSELECTING ATTENDEE:\n");
    printf("  attendees           = %d\n", attendees);
    printf("  absentees           = %d\n", absentees);
    printf("  sample              = %d\n", sample);
*/

    for ( i : 0 .. N - 1 ) {
//        printf("  i = %d v = %d s = %d g = %d\n", i, selection, sample, selection == NONE && membership[i]);
        if
        :: selection == NONE && membership[i] && sample != 0 -> sample--
        :: selection == NONE && membership[i] && sample == 0 -> selection = i
        :: else
        fi
    }

    selectedID = selection;
//    printf("  selection           = %d\n", selectedID);

}   }


/****
  * External result variable(s):
  *   - selectedID
****/
inline select_absentee( t )
{   atomic {

    byte sample;
    byte selection = NONE;

    take_attendance( t );
    select( sample : 0 .. absentees - 1 );

/*
    printf("\nSELECTING ABSENTEE:\n");
    printf("  attendees           = %d\n", attendees);
    printf("  absentees           = %d\n", absentees);
    printf("  sample              = %d\n", sample);
*/

    for ( i : 0 .. N - 1 ) {
//        printf("  i = %d v = %d s = %d g = %d\n", i, selection, sample, selection == NONE && membership[i]);
        if
        :: selection == NONE && !membership[i] && sample != 0 -> sample--
        :: selection == NONE && !membership[i] && sample == 0 -> selection = i
        :: else
        fi
    }

    selectedID = selection;
//    printf("  selection           = %d\n", selectedID);

}   }


/****
  * External result variable(s):
  *   - senderID
****/
inline select_sender( commitment )
{
    byte selectedID;
    select_sender_constrained( NONE, false, commitment );
    senderID = selectedID;
}


/****
  * External result variable(s):
  *   - exiledID
  *
  * Similar to select_attendee
****/
inline select_exiled( forced, commitment )
{
    byte selectedID;
    select_sender_constrained( NONE, forced, commitment );
    exiledID = selectedID;
}


/****
  * External result variable(s):
  *   - banisherID
****/
inline select_banisher( banned, commitment )
{
    byte selectedID;
    select_sender_constrained( banned, false, commitment );
    banisherID = selectedID;
}


/****
  * External result variable(s):
  *   - updaterID
****/
inline select_updater( forced, commitment )
{
    byte selectedID;
    select_sender_constrained( NONE, forced, commitment );
    updaterID = selectedID;
}



/****
  * External result variable(s):
  *   - selectedID
****/
inline select_sender_constrained ( banned, forced, commitment )
{ atomic {
    printf("\nSELECTING Sender %d %d %d", banned, forced, commitment);

    byte candidates = 0;
    d_step {
        for ( i : 0 .. N - 1 ) {
/*
             d_step
             {
                 printf("\n  membership[%d]     = %d", i, membership[i]);
                 printf("\n  i != banned        = %d", i != banned  );
                 printf("\n  !forced            = %d", !(forced)    );
                 printf("\n  commitment         = %d",  commitment);
                 printf("\n  !epochQuerried[%d] = %d", i, !(epochQuerried[i]));
                 printf("\n  unsafe[%d]         = %d", i, unsafe[i]);
                 printf("\n");
                 printf("\n  commitment || !(epochQuerried[%d]) = %d", i, (commitment || !(epochQuerried[i])));
                 printf("\n  (!(forced) && (commitment || !(epochQuerried[%d]))) = %d", i, !(forced) && (commitment || !(epochQuerried[i])));
                 printf("\n  (!(forced) && (commitment || !(epochQuerried[%d]))) || unsafe[%d] = %d", i, i, (!(forced) && (commitment || !(epochQuerried[i]))) || unsafe[i]);
                 printf("\n")
             }
*/
             if
             :: membership[i] && i != banned &&
                ((!(forced) && (commitment || !(epochQuerried[i]))) || unsafe[i]) -> candidates++
             :: else
             fi
        }
    }

    if
    :: candidates == 0 -> selectedID = NONE
    :: else ->
        byte sample;
        select( sample : 0 .. candidates - 1 );
        byte selection = NONE;
        d_step
        {
    /**/
            printf("\n  candidates         = %d", candidates);
            printf("\n  sample             = %d", sample);
    /**/
    
            for ( i : 0 .. N - 1 ) {
                printf("\n\ti = %d v = %d s = %d b = %d", i, selection, sample, membership[i] && i != banned && ((!(forced) && (commitment || !(epochQuerried[i]))) || unsafe[i]));
                if
                :: selection == NONE ->
                    if
                    :: membership[i] && i != banned &&
                       ((!(forced) && (commitment || !(epochQuerried[i]))) || unsafe[i]) ->
                        if
                        :: sample == 0 -> selection = i
                        :: sample != 0 -> sample--
                        fi
                    :: else
                    fi
                :: else
                fi
            }
        }
        selectedID = selection;
    fi
}   }



/****
  * External result variable(s):
  *   - joinerID
****/
inline select_joiner( input )
{
    d_step
    {
        byte selectedID;
        select_absentee( input );
        joinerID = selectedID;
    }
}


/****
  * External result variable(s):
  *   - corruptedID
  *
  * Similar to select_attendee
****/
inline select_corrupted( t )
{   atomic {

    byte candidateCorrupteds;
    candidate_corrupteds( t );
    if
    :: candidateCorrupteds == 0 -> corruptedID = NONE
    :: else ->
        byte sample;
        select ( sample : 0 .. candidateCorrupteds - 1 );
        byte selection = NONE;
        d_step
        {
            for ( i : 0 .. N )
            {
                if
                :: selection == NONE ->
                    if
                    :: hoarding[i] == NONE && attackerKnowledge[t].node[i] == UnknownNode ->
                        if
                        :: sample == 0 -> selection = i
                        :: sample != 0 -> sample--
                        fi
                    :: else
                    fi
                :: else
                fi
            }
        }
        corruptedID = selection
    fi
}   }


inline candidate_corrupteds( t )
{
    safety_poll();
    byte remainingEpochs = T - t - 1

    if
    :: unsafeIDs >= T - t - 1 -> candidateCorrupteds = 0;
    :: else ->
        byte candidates = 0;
        d_step
        {
            for ( i : 0 .. N - 1 )
            {   // The corrupted user must not previously been instructed to hoard!
                // Violates the "Safety Predicate SAFE" described in Alwen 2020.
                if
                :: hoarding[i] == NONE && attackerKnowledge[t].node[i] == UnknownNode -> candidates++
                :: else
                fi
            }
        }
        candidateCorrupteds = candidates
    fi
}



/****
  * External result variable(s):
  *   - currentEpoch
****/
/*
inline current_epoch()
{   d_step {

    byte x = 0;
    for ( i : 0 .. T - 1 )
    {
        if
        :: leadership[i] != NONE -> x++
        :: else
        fi
    }
    currentEpoch = t;

}   }
*/


/****
  * External result variable(s):
  *   - selectedEpoch
****/
inline select_epoch( input )
{   atomic {

    byte anyEpoch;
    select ( anyEpoch : 0 .. input );
    selectedEpoch = anyEpoch;

}   }


/****
  * External result variable(s):
  *   - revelationEpoch
****/
/*
inline select_revelation( t )
{   atomic {

    byte candidateEpochs = 0
    byte challengesUsed  = 0
    d_step
    {
        for ( i : 0 .. t )
        {
            if
            ::  challenge[i] -> challengesUsed++
            :: !challenge[i] && attackerKnowledge[i].node[ROOT] == UnknownNode -> candidateEpochs++
            ::  else
            fi
        }
    }
    
    byte selection = NONE;
    if
    :: candidateEpochs > 0 && challengesUsed < C ->
        byte sample;
        select ( sample : 0 .. candidateEpochs - 1 );
        for ( i : 0 .. t )
        {
            if
            :: selection == NONE ->
                if
                :: !challenge[i] && attackerKnowledge[i].node[ROOT] == UnknownNode ->
                    if
                    :: sample == 0 -> selection = i
                    :: sample != 0 -> sample--
                    fi
                :: else
                fi
            :: else
            fi
        }
    :: else
    fi

    revelationEpoch = selection

}   }
*/


/****
  * External result variable(s):
  *   - hoarderID
****/
inline select_hoarder()
{   atomic {

    byte candidateHoarders;
    candidate_hoarders();
    
    if
    :: candidateHoarders == 0 -> hoarderID = NONE
    :: else ->
        byte sample;
        select ( sample : 0 .. candidateHoarders - 1 );
        byte selection = NONE;
        d_step
        {
            for ( i : 0 .. N - 1 )
            {
                if
                :: sample == 0 && selection == NONE && hoarding[i] == NONE && membership[i] -> selection = i
                :: sample != 0 && selection == NONE && hoarding[i] == NONE && membership[i] -> sample--
                :: else
                fi
            }
        }
        hoarderID = selection
    fi
}   }


inline candidate_hoarders()
{
    byte candidates = 0;
    for ( i : 0 .. N - 1 )
    {
        if
        :: hoarding[i] == NONE && membership[i] -> candidates++
        :: else -> skip
        fi
    }
    candidateHoarders = candidates
}


/****
  * External result variable(s):
  *   - messagePending
  *   - messageVacancy
****/
/*
inline message_status()
{   d_step {

//    printf("\nCHECKING AVAILABLE MESSAGES:\n");
    byte pending = false;
    bool vacancy = true;
    for ( i : 0 .. N - 1 )
    {
        pending = pending || nempty( M[i] );
        vacancy = vacancy &&  nfull( M[i] );
    }
    messagePending = pending;
    messageVacancy = vacancy;
}   }
*/


/****
  * External result variable(s):
  *   - recipientID
****/
/*
inline select_recipient()
{   atomic {

//    printf("\nSELECT RECIPIENT:\n");

    byte availableRecipient = 0;
    for ( i : 0 .. N - 1 )
    {
        if
        :: nempty(M[i]) -> availableRecipient++
        ::  empty(M[i]) -> skip
        fi
    }

//    printf("\nAvailable Recipients: %d\n", availableRecipient);

    byte sample;
    select( sample : 0 .. availableRecipient - 1 )

//    printf("\nSample: %d\n", sample);

    byte selection = NONE;
    bool content;
    for ( i : 0 .. N - 1 )
    {
        content =  nempty(M[i]);
//        printf("\n  i: %d  v: %d  s: %d  q: %d\n", i, selection, sample, content);
        if
        :: selection == NONE && nempty( M[i] ) && sample == 0 -> selection = i
        :: selection == NONE && nempty( M[i] ) && sample != 0 -> sample--
        :: selection == NONE &&  empty( M[i] ) && sample == 0 -> skip
        :: selection != NONE -> skip
        fi
    }
    
//    printf("\nRecipient: %d\n", selection);
    recipientID = selection;

}   }
*/


/****
  * External result variable(s):
  *   - forcedPlay
****/
inline forced_play( t ) {
    d_step {
        byte remainingEpochs = T - t - 1;
        safety_poll();
        assert( T - t - 1 >= unsafeIDs );
        forcedPlay = unsafeIDs > 0 && unsafeIDs == remainingEpochs;
    }
}


/****
  * External result variable(s):
  *   - commitEpochAdvance
****/
inline decide_commitment()
{
    do
    :: commitEpochAdvance = true;  break
    :: commitEpochAdvance = false; break
    od
}


/****
  *
  * The following methods:
  *   - broadcast
  *   - propogate
  *
  * Are used by the security game moves:
  *   - insert_member
  *   - remove_member
  *   - oblige_update
  *
****/


inline broadcast ( t, sender, subject, commitment, message )
{
    atomic
    {
        // Attacker observes network messages
        for ( i : 0 .. N - 1 ) {
            if
            :: ((message != RMV || i != subject) && membership[i]) ||
               ( message == ADD && i == subject) ||
               ( message == UPD && membership[i] ) ->
                printf("\n OBSERVING: %d -> %d : %e @ %d", sender, i, message, subject)
                // attacker_observes_message( t, sender, i, commitment, message );
            :: else
            fi
        };

/*
        if
        :: commitment -> leadership[t] = sender
        :: else
        fi
*/
    }
}


inline attacker_observes_message( t, sender, commitment, message )
{
    // Row 1, leaves
    for ( i : 0 .. N - 1 )
    {
        if
        // No knowledge from excluded group members
        :: !membership[i] ->
            attackerKnowledge[t].node[i] = Void
        // The sender has refreshed their secrets, hence Unknown
        :: membership[i] && (i == sender || attackerKnowledge[t].node[i] != KnownNode) ->
            attackerKnowledge[t+1].node[i] = UnknownNode
        :: membership[i] &&  i != sender && attackerKnowledge[t].node[i] == KnownNode  ->
            attackerKnowledge[t+1].node[i] = KnownNode
        fi
    }

    // Row 2, parents
    for ( i : N .. N + (N / 2) )
    {
        byte c0 = i - N
        byte c1 = i - N + 1
        if
        // If neither child exists in this epoch
        :: attackerKnowledge[t+1].node[c0] == Void && attackerKnowledge[t+1].node[c1] == Void ->
            attackerKnowledge[t+1].node[i] = Void
        // If only the left child exists in this epoch
        :: attackerKnowledge[t+1].node[c0] != Void && attackerKnowledge[t+1].node[c1] == Void ->
            if
            :: attackerKnowledge[t+1].node[c0] == KnownNode || attackerKnowledge[t+1].node[c0] == KnownRefs ->
                attackerKnowledge[t+1].node[i] =  KnownRefs
            :: else
                attackerKnowledge[t+1].node[i] = UnknownRefs
            fi
        // If only the right child exists in this epoch
        :: attackerKnowledge[t+1].node[c0] == Void && attackerKnowledge[t+1].node[c1] != Void ->
            if
            :: attackerKnowledge[t+1].node[c1] == KnownNode || attackerKnowledge[t+1].node[c1] == KnownRefs ->
                attackerKnowledge[t+1].node[i] =  KnownRefs
            :: else
                attackerKnowledge[t+1].node[i] = UnknownRefs
            fi
        // If both children exist in this epoch
        :: attackerKnowledge[t+1].node[c0] != Void && attackerKnowledge[t+1].node[c1] != Void ->
            if
            // If both children existed in the previous epoch
            :: (attackerKnowledge[t].node[c0] == KnownNode || attackerKnowledge[t].node[c0] == UnknownNode) &&
               (attackerKnowledge[t].node[c1] == KnownNode || attackerKnowledge[t].node[c1] == UnknownNode) ->
               if
               :: attackerKnowledge[t].node[c0] == KnownNode || attackerKnowledge[t].node[c0] == KnownNode ->
                   attackerKnowledge[t+1].node[i] = KnownNode
               :: else
                   attackerKnowledge[t+1].node[i] = UnknownNode
               fi
            :: else
                   attackerKnowledge[t+1].node[i] = UnknownNode            
            fi
        fi
    }

/*
    if
    :: N > 4 ->
    for ( i : N .. N + (N / 2) )
    {
        c0 = i - N
        c2 = i - N + 1
        if
        // If neither child exists in this epoch
        :: attackerKnowledge[t].node[c0] == Void && attackerKnowledge[t].node[c1] == Void ->
            attackerKnowledge[t].node[i] = Known
        // If only the left child exists in this epoch
        :: attackerKnowledge[t].node[c0] != Void && attackerKnowledge[t].node[c1] == Void ->
            attackerKnowledge[t].node[i] = Space
        // If only the right child exists in this epoch
        :: attackerKnowledge[t].node[c0] == Void && attackerKnowledge[t].node[c1] != Void ->
            attackerKnowledge[t].node[i] = Space
        // If both children exist in this epoch
        :: attackerKnowledge[t].node[c0] != Void && attackerKnowledge[t].node[c1] != Void ->
            if
            // If both children existed in the previous epoch
            :: (attackerKnowledge[e].node[c0] == Known || attackerKnowledge[e].node[c0] == Unknown) &&
               (attackerKnowledge[e].node[c1] == Known || attackerKnowledge[e].node[c1] == Unknown) && ->
               if
               :: attackerKnowledge[e].node[c0] == Known || attackerKnowledge[e].node[c0] == Known ->
                   attackerKnowledge[t].node[i] = Known
               :: else
                   attackerKnowledge[t].node[i] = Unknown
               fi
            :: else
                   attackerKnowledge[t].node[i] = Unknown                
            fi
        fi
    }
*/

}


inline propogate ( t, sender, insert, remove )
{
    d_step {
        for ( i : 0 .. N - 1 )
        {
            epochQuerried[i] = false
        }
        if
        :: insert != NONE -> membership[insert] = true
        :: remove != NONE -> membership[remove] = false
        :: else
        fi
    }
}


/********
    *
    * Oracles available to the attacker:
    *
    *   - Corrupt
    *   - Hoard
    *   - Reveal
    *
********/


inline corrupt( t, memberID )
{   atomic {

    // Learn the secret material of the user in their current epoch
    attackerKnowledge[t].node[memberID] = KnownNode;
    unsafe[memberID] = true;

    // Learn any additional secrets they have hoarded!
    byte epochSavedFrom = hoarding[memberID];
    if
    :: epochSavedFrom < t ->
        for ( i : epochSavedFrom .. t)
        {
            attackerKnowledge[i].node[memberID] = KnownNode;
        }
    :: else
    fi

}   }


inline hoard( t, memberID )
{
    hoarding[memberID] = t
}


inline reveal( t )
{
    d_step {
        challenge[t] = true;
        attackerKnowledge[t].node[ROOT] -> KnownNode;
    }
}


/********
    *
    * Oracles available to the Group Members:
    *
    *   - Insert Member ( ADD )
    *   - Remove Member ( RMV )
    *   - Oblige Update ( UPD )
    *   - Convey Update ( DLV )
    *
********/


// Precondition: joiner is not in the group!
inline insert_member( t, sender, joiner, commitment )
{
    d_step {
//        printf("\nINSERT MEMBER:\n  Inviter: %d\n  joiner: %d\n  Epoch: \t%d\n", sender, joiner, t)
        assert(sender < N);
        assert(joiner < N);
    }
    if
    :: !commitment -> epochQuerried[sender] = true;
    ::  commitment -> propogate ( t, sender, joiner, NONE );
    fi
    broadcast( t, sender, joiner, commitment, ADD );
}


// Precondition: exiledMemeber is in the group!
inline remove_member( t, sender, exiled, commitment )
{
    d_step {
//        printf("\nREMOVE MEMBER:\n  Sender: \t%d\n  Exiled: \t%d\n  Epoch: \t%d\n", sender, exiled, t);
        assert(sender < N);
        assert(exiled < N);
    }
    if
    :: !commitment -> epochQuerried[sender] = true;
    ::  commitment -> propogate ( t, sender, NONE, exiled); unsafe[exiled] = false;
    fi
    broadcast( t, sender, exiled, commitment, RMV );
}


inline oblige_update( t, sender, commitment )
{
    d_step {
//        printf("\nOBLIGE UPDATE:\n  Sender: \t%d\n  Epoch: \t%d\n", sender, t);
        assert(sender < N);
    }
    if
    :: !commitment -> epochQuerried[sender] = true;
    ::  commitment -> propogate ( t, sender, NONE, NONE ); unsafe[sender] = false;
    fi
    broadcast( t, sender, NONE, commitment, UPD );
}


/*
inline convey_update( t, receiver )
{
    d_step {
//        printf("\nUPDATE MESSAGE:\n  Target\t %d\n  Epoch \t %d\n  Sender\t %d\n", receiver, e, sender);
        if
        :: leadership[t] == NONE ->
            leadership[t] = sender;
            printf("SET leadership[%d] <- %d\n", t, sender);
        :: else
        fi
    }
}
*/


inline initialize_attacker_knowledge()
{
    d_step
    {
        for( i : 0 .. T - 1 )
        {
            for( j : N .. TREE - 1)
            {
                attackerKnowledge[i].node[j] = Void
            }
        }
    }
}


/********
    *
    * Initialization inline routines, in order of execution:
    *
    *   - Initialize
    *   - Select Group
    *   - Create Group
    *   - CGKA Security Game
    *
********/


inline CGKA_initialize()
{   atomic {
    printf("\n***********************\n* CGKA: Initialize!   *\n***********************\n");

    d_step
    {
        for( i : 0 .. N - 1 )
        {
//            epoch[i] = 0;
            hoarding[i]  = NONE;
        };
    
        for( i : 0 .. T - 1 )
        {
            challenge[i] = false;
//            leadership[i]  = NONE;
        };
    
        for ( i : 0 .. N - 1 )
        {
            epochQuerried[i] = false;
        }
    };

    initialize_attacker_knowledge()

}   }


inline CGKA_create_group()
{   atomic {
    printf("\n***********************\n* CGKA: Create Group! *\n***********************\n");

    byte id0, n, t;
    
    // Set the "lead" byte to be the first member in the group.
    d_step
    {
        id0 = 0;
        t   = 0;
    }

    // Number of members to add
    select ( n : 2 .. N );
    for( i : 0 .. N - 1 )
    {
        membership[i] = i < n;
    };

    print_membership();
    
    broadcast ( t, id0, NONE, true, UPD );

/*
    for( i : 0 .. N - 1 )
    {
        if
        :: membership[i] -> convey_update( t, i )
        :: else
        fi
    };
*/

}   }


/*
inline CGKA_security_game()
{
    printf("\n***********************\n* CGKA: Begin Play!   *\n***********************\n");
    bool endGame = false;
    endHere:
    do
    :: !endGame -> atomic
        {
            byte currentEpoch=0;
            byte revelationEpoch;
            bool forcedPlay, groupDyad, groupFull, messagePending, messageVacancy;
            byte corruptedID, exiledID, banisherID, hoarderID, updaterID;

            atomic
            {
//                printf("\nPRECOMPUTE GUARDS:\n");
    
//                current_epoch();
//                message_status();
                forced_play(       currentEpoch );
                group_dyad(        currentEpoch );
                group_full(        currentEpoch );
                select_revelation( currentEpoch );
                select_corrupted(  currentEpoch );
                select_hoarder(    currentEpoch );
                select_updater(    currentEpoch, forcedPlay );
                select_exiled(     currentEpoch, forcedPlay );
                select_banisher(   currentEpoch, exiledID   );
            };

            print_global_state()

            d_step
            {
                printf("  currentEpoch    = %d\n", currentEpoch);
                printf("  messagePending  = %d\n", messagePending);
                printf("  messageVacancy  = %d\n", messageVacancy);
                printf("  forcedPlay,     = %d\n", forcedPlay);
                printf("  groupDyad       = %d\n", groupDyad);
                printf("  groupFull       = %d\n", groupFull);
                printf("  absentees       = %d\n", absentees);
                printf("  attendees       = %d\n", attendees);
                printf("  revelationEpoch = %d\n", revelationEpoch);
                printf("  corruptedID     = %d\n", corruptedID);
                printf("  hoarderId       = %d\n", hoarderID);
            }


            d_step
            {
                printf("\nPRINT GLOBAL STATE:\n");
    
                printf("\n  lead:\n    [ ");
                for ( i : 0 .. T - 1)
                {
                    if
                    :: i == 0 -> printf(  "%d ", leadership[i])
                    :: i != 0 -> printf("| %d ", leadership[i])
                    fi
                }
                printf("]\n");
    
                printf("\n  chall:\n    [ ");
                for ( i : 0 .. T - 1)
                {
                    if
                    :: i == 0 -> printf(  "%d ", challenge[i])
                    :: i != 0 -> printf("| %d ", challenge[i])
                    fi
                }
                printf("]\n");
    
                printf("\n  ep:\n    [ ");
                for ( i : 0 .. T - 1)
                {
                    if
                    :: i == 0 -> printf(  "%d ", epoch[i])
                    :: i != 0 -> printf("| %d ", epoch[i])
                    fi
                }
                printf("]\n");
    
                printf("\n  M:\n    [ ");
                for ( i : 0 .. N - 1)
                {
                    byte v = len(M[i]);
                    if
                    :: i == 0 -> printf(  "%d ", v)
                    :: i != 0 -> printf("| %d ", v)
                    fi
                }
                printf("]\n");
            };

            do
            // ****************************************************
            // *
            // *  Corrupt
            // **
            :: corruptedID != NONE && !forcedPlay -> atomic
                {
                    printf("\n> > >\n> CGKA: Game Move = corrupt %d\n> > >\n", corruptedID);
                    corrupt( corruptedID )
                }; break
            // ****************************************************
            // *
            // *  Hoard
            // **
            :: hoarderID != NONE -> atomic
                {
                    printf("\n> > >\n> CGKA: Game Move = hoard %d\n> > >\n", hoarderID);
                    hoard( hoarderID )
                }; break
            // ****************************************************
            // *
            // *  Reveal
            // **
            :: revelationEpoch != NONE -> atomic
                {
                    printf("\n> > >\n> CGKA: Game Move = reveal %d\n> > >\n", revelationEpoch);
                    reveal( revelationEpoch )
                }; break
            // ****************************************************
            // *
            // *  Convey
            // **
            /*
            :: messagePending -> atomic
                {   // Selection
                    byte recipientID;
                    select_recipient();
                    // Execution
                    printf("\n> > >\n> CGKA: Game Move = convey_update %d\n> > >\n", recipientID);
                    convey_update ( recipientID );
                }; break
            // ****************************************************
            // *
            // *  Update
            // **
            :: messageVacancy && updaterID != NONE -> atomic
                {
                    bool commitEpochAdvance;
                    decide_commitment();
                    printf("\n> > >\n> CGKA: Game Move = oblige_update %d (committed? %d)\n> > >\n", updaterID, commitEpochAdvance);
                    oblige_update( currentEpoch, updaterID, commitEpochAdvance );
//                    convey_update( updaterID );
                }; break
            // ****************************************************
            // *
            // *  Remove
            // **
            :: !groupDyad && messageVacancy && exiledID != NONE && banisherID != NONE -> atomic
                {
                    bool commitEpochAdvance;
                    decide_commitment();
                    printf("\n> > >\n> CGKA: Game Move = remove_member %d %d (committed? %d)\n> > >\n", banisherID, exiledID, commitEpochAdvance);
                    remove_member( currentEpoch, banisherID, exiledID, commitEpochAdvance );
//                    convey_update( banisherID );
                }; break
            // ****************************************************
            // *
            // *  Insert
            // **
            :: !groupFull && !forcedPlay && messageVacancy -> atomic
                {   // Selection
                    byte joinerID, senderID;
                    select_sender( currentEpoch );
                    select_joiner( currentEpoch );
                    bool commitEpochAdvance;
                    decide_commitment();
                    // Execution
                    printf("\n> > >\n> CGKA: Game Move = insert_member %d %d (committed? %d)\n> > >\n", senderID, joinerID, commitEpochAdvance);
                    insert_member( currentEpoch, senderID, joinerID, commitEpochAdvance );
//                    convey_update( senderID );
                }; break
            od;

           // **
           // *  Post game move update.
           // **
            d_step
            {
                // After the operation is complete, check to see if the an endgame condition has been reached.
//                current_epoch();
                safety_poll();
                endGame = unsafeIDs == 0;
                printf ("\n< < <\n< Moves:   %d\n< Unsafe:  %d\n< Endgame: %d\n< < < \n", T - currentEpoch - 1, unsafeIDs, endGame);
            };
        }
    :: else -> break
    od   
}
*/

inline CGKA_safety_check()
{
    printf("\n***********************\n* CGKA: Safety Check! *\n***********************\n");

    printf("\n? ? ? ? ? ? ? ? ? ? ? ?\n? Attacker  Knowledge ?\n? ? ? ? ? ? ? ? ? ? ? ?\n");
    
    for( t : 0 .. T - 1 )
    {
        printf("\n>>> %d vvv", t);
        for( i : 0 .. TREE - 1 )
        {
            if
            :: attackerKnowledge[t].node[i] == UnknownRefs -> printf("\n\t%d [ x ]", i)
            :: attackerKnowledge[t].node[i] == UnknownNode -> printf("\n\t%d [ X ]", i)
            :: attackerKnowledge[t].node[i] ==   KnownRefs -> printf("\n\t%d [ o ]", i)
            :: attackerKnowledge[t].node[i] ==   KnownNode -> printf("\n\t%d [ O ]", i)
            :: else                                        -> printf("\n\t%d [ ? ]", i)
            fi
        }
    };
    printf("\n");
}


inline new_loop_outline()
{
    for ( t : 0 .. T - 2)
    {
        bool commitmentRequired = false;
        
        do
        // NOTE: The attacker can always play a move which commits to a new epoch
        :: play_move_with_commitment( t ); break
        
        // NOTE: Alternatively, the attacker can play a non-committal move and remain in the same epoch
        :: !commitmentRequired -> atomic
            {
               play_noncommittal_move( t );
               check_commitment_required( t );
               printf("POST-noncommittal");
            };
        od;
        printf("LOOP broken: %d", t);

        d_step
        {
            // After the operation is complete, check to see if the an endgame condition has been reached.
            safety_poll();
            printf ("\n< < <\n< Moves:   %d\n< Unsafe:  %d\n< < < \n", T - t - 1, unsafeIDs);
        }
    }
    loopFinal: skip
    finishedLoop = true;
/*
    bool endGame = false;
    do
    :: endGame -> break
    :: atomic
        {
           play_noncommittal_move( t );
           d_step
           {
               // After the operation is complete, check to see if the an endgame condition has been reached.
               safety_poll();
               endGame = unsafeIDs == 0;
               printf ("\n< < <\n< Moves:   %d\n< Unsafe:  %d\n< Endgame: %d\n< < < \n", T - t - 1, unsafeIDs, endGame);
           }
        };
    od;
*/
}


inline can_reveal( t )
{
    byte challengesUsed = 0;
    d_step
    {
        for ( i : 0 .. t )
        {
            if
            :: challenge[i] -> challengesUsed++;
            :: else
            fi
        }
    };

    canReveal = !challenge[t] && challengesUsed < C && attackerKnowledge[i].node[ROOT] == UnknownNode && (t != T - 1);
}


inline can_query()
{
    byte querriesUsed = 0;
    byte groupSize    = 0;
    d_step
    {
        for ( i : 0 .. N - 1 )
        {
            if
            :: epochQuerried[i] -> querriesUsed++
            :: else
            fi;
            
            if
            :: membership[i] -> groupSize++
            :: else
            fi
        }
    };
    
    printf("\n\tquerriesUsed < groupSize - 1\n\t%d < %d - 1 = %d", querriesUsed, groupSize, querriesUsed < groupSize - 1);

    // Cannot send a final test mail when there is only one untested member remaining.
    // The last member will be the commitment member.
    canQuery = querriesUsed < groupSize - 1;
}


inline check_commitment_required( t )
{
    bool canQuery;
    can_query();
    printf("\n canQuery = %d", canQuery);

    bool canReveal;
    can_reveal( t );
    printf("\n canReveal = %d", canReveal);

    bool canHoardMember = false;
    d_step
    {
        byte candidateHoarders;
        candidate_hoarders();
        canHoardMember = candidateHoarders > 0;
        printf("\n canHoardMember = %d", canHoardMember);
    }

    bool canCorruptMember = false;
    d_step
    {
        byte candidateCorrupteds;
        candidate_corrupteds( t );
        canCorruptMember = candidateCorrupteds > 0;
        printf("\n canCorruptMember = %d", canCorruptMember);
    }

    commitmentRequired = !canQuery && !canReveal && !canHoardMember && !canCorruptMember
}


inline play_noncommittal_move( t )
{
    bool canQuery, canReveal, forcedPlay, groupDyad, groupFull;
    byte corruptedID, exiledID, banisherID, hoarderID, updaterID;

    assign_move_variables( t, false );
    printf("\nNON-Committal!");

    do
    // Non-committing moves
    :: canQuery -> play_move_maybe_commitment( t, false ); break

    //  Reveal
    :: canReveal -> atomic
        {   printf("\n> > >\n> CGKA: Game Move = reveal %d\n> > >\n", t);
            reveal( t )
        }; break

    //  Corrupt
    :: corruptedID != NONE && !forcedPlay -> atomic
        {   printf("\n> > >\n> CGKA: Game Move = corrupt %d\n> > >\n", corruptedID);
            corrupt( t, corruptedID )
        }; break

    //  Hoard
    :: hoarderID != NONE -> atomic
        {   printf("\n> > >\n> CGKA: Game Move = hoard %d\n> > >\n", hoarderID);
            hoard( t, hoarderID )
        }; break

/*
    //  Convey
    :: messagePending -> atomic
        {
            byte recipientID;
            select_recipient();
            printf("\n> > >\n> CGKA: Game Move = convey_update %d\n> > >\n", recipientID);
            convey_update ( recipientID );
        }; break
*/        
    od
}


inline play_move_with_commitment( t )
{
    bool canQuery, canReveal, forcedPlay, groupDyad, groupFull;
    byte corruptedID, exiledID, banisherID, hoarderID, updaterID;
    
    assign_move_variables( t, true );
    printf("\nCOMMITTING!");
    play_move_maybe_commitment( t, true )
}


inline assign_move_variables( t, commitment )
{
    atomic
    {
//        message_status();
        can_query();
        can_reveal(  t );
        forced_play( t );
        group_dyad(  t );
        group_full(  t );
//        select_revelation( t );
        select_corrupted(  t );
        select_hoarder();
        select_updater(  forcedPlay && commitment, commitment );
        select_exiled(   forcedPlay && commitment, commitment );
        select_banisher( exiledID                , commitment );
    };
    printf("\nEpoch (t) = %d", t);
    print_global_state()

    d_step
    {
        printf("\n\tcanQuery    \t%d",    canQuery );
        printf("\n\tforcedPlay  \t%d",  forcedPlay );
        printf("\n\tgroupDyad   \t%d",   groupDyad );
        printf("\n\tgroupFull   \t%d",   groupFull );
        printf("\n\tcorruptedID \t%d", corruptedID );
        printf("\n\texiledID    \t%d",    exiledID );
        printf("\n\tbanisherID  \t%d",  banisherID );
        printf("\n\thoarderID   \t%d",   hoarderID );
        printf("\n\tupdaterID   \t%d",   updaterID );
    }
}


inline play_move_maybe_commitment( t, commitment )
{
    do
    // Update
    :: updaterID != NONE -> atomic
        {   printf("\n> > >\n> CGKA: Game Move = oblige_update %d (committed? %d)\n> > >\n", updaterID, commitment);
            oblige_update( t, updaterID, commitment );
        }; break

    // Remove
    :: !groupDyad && exiledID != NONE && banisherID != NONE -> atomic
        {  printf("\n> > >\n> CGKA: Game Move = remove_member %d %d (committed? %d)\n> > >\n", banisherID, exiledID, commitment);
            remove_member( t, banisherID, exiledID, commitment );
        }; break

    // Insert
    :: !groupFull && !forcedPlay -> atomic
        {
            byte joinerID, senderID;
            select_sender( commitment );
            select_joiner( t );
            printf("\n> > >\n> CGKA: Game Move = insert_member %d %d (committed? %d)\n> > >\n", senderID, joinerID, commitment);
            insert_member( t, senderID, joinerID, commitment );
        }; break
    od
}


init
{
    CGKA_initialize();
    CGKA_create_group();
    new_loop_outline();
//    CGKA_security_game();
    CGKA_safety_check();
}

ltl finished_loop { <>finishedLoop }
//ltl attendees_more_than_one { [](attendees > 1) }
//ltl attendees_absentees_sum { [](attendees + absentees == N) }
