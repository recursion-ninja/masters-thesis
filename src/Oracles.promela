/********
    *
    * Advantage:
    *
    * In the following, a (`t`, `c`, `n`)-attacker is an attacker `A` that runs in time at most `t`,
    * makes at most `c` challenge queries, and never produces a group with more than `n` members.
    * The attacker wins the CGKA security game if they correctly guesses the random bit `b` in
    * the end and the safety predicate `P` evaluates to true on the queries made by the attacker.
    *
    * Hence we define our (`t`, `c` `n`) constants below:
    *
********/

// A constant for missing data
#define NONE 255

/****
  *
  * Security game's parameters' valid ranges:
  *   - T <- [3, 255]
  *   - C <- [1,   T]
  *   - N <- [3, 127]
  *
  * Lookup table for TREE value derived from N:
  *   - [ 1,   1] ->   1
  *   - [ 2,   2] ->   3
  *   - [ 3,   4] ->   7
  *   - [ 5,   8] ->  15
  *   - [ 9,  16] ->  31
  *   - [17,  32] ->  63
  *   - [33,  64] -> 127
  *   - [65, 128] -> 255
  *
****/
#define T    3
#define C    3
#define N    4
#define TREE 7
#define NODE (TREE / 2)
#define ROOT 0


/****
  *
  * Special types required for the protocol.
  *
****/
mtype:Message = { ADD, RMV, UPD };

typedef Group      { bool         membership[N] };


/****
  *
  * Global state of the CGKA security game.
  *
****/

byte    lead[T]; // Who initiated the epoch?
Group      G[T]; // Group membership by epoch
bool   chall[T]; // Has the attacker challenged in an epoch?
byte      ep[N]; // The epoch of each user
byte       D[N]; // Epoch from which the user saves secrets
bool  unsafe[N]; // Members which require a change to update
bool endGame;    // Are there more moves to be played?

// Epoch, Sender
chan M[N] = [2] of { byte, byte };


/****
  *
  * Global state of the attacker.
  *
****/

//        Void - This node does not exist  and there exists 0 leaves in the subtree
// UnknownRefs - This node does not exist  and there exists 1 leaf   in the subtree
//   KnownRefs - This node does not exist  and there exists 1 leaf   in the subtree
// UnknownNode - This node          exists and there exists 1 or more leaves in the subtree
//   KnownNode - This node          exists and there exists 1 or more leaves in the subtree
mtype:Secret = { Void, UnknownRefs, KnownRefs, UnknownNode, KnownNode };

typedef TreeKeys   { mtype:Secret node[ TREE ]  };

TreeKeys attackerKnowledge[T];

/****
  *
  * Left-balanced Binary Tree:
  *
  *            +-----(14)-----+
  *           /                \
  *         (12)              (13)
  *        /    \            /    \
  *     (8)     (9)       (10)     (11)
  *    /   \   /   \     /    \   /    \
  *   0     1 2     3   4      5 6      7 
  *
  * Binary Heap Layout:
  *
  * Index:   0   1   2   3   4   5   6   7   8   9  10  11  12  13  14
  * Array: [  ][  ][  ][  ][  ][  ][  ][  ][  ][  ][  ][  ][  ][  ][  ]
  * Node:   14  12  13   8   9  10  11   0   1   2   3   4   5   6   7
  *
****/


/****
  *
  * Global (local) variable for inline functions.
  *
****/

local byte i = 0;
local byte j = 0;
local byte k = 0;
local byte t = 0;
local byte absentees = 0;
local byte attendees = N;
local byte unsafeIDs = 0;


/********
    *
    * Global state priniting utilities:
    *
    *   - print_challenges
    *   - print_leadership
    *   - print_membership
    *
********/


inline print_challenges()
{
    d_step {
        printf("\n\tChallenges:");
        for ( i : 0 .. T - 1)
        {
            if
            :: chall[i] -> printf("\n\t    [\tTrue\t]");
            :: else     -> printf("\n\t    [\tFalse\t]");
            fi
        }
        printf("\n");
    }
}


inline print_leadership()
{
    d_step {
        printf("\n\tLeadership:");
        for ( i : 0 .. T - 1)
        {
            if
            :: lead[i] == NONE -> printf("\n\t    [\tNONE\t]")
            :: else            -> printf("\n\t    [\t%d\t]", lead[i])
            fi
        }
        printf("\n");
    }
}


inline print_membership()
{
    d_step {
        byte e = 0;
        for ( i : 0 .. T - 1 )
        {
           if
           :: lead[i] != NONE -> e++
           :: else
           fi
        }
        
        printf("\n\tMembership:");
        for ( i : 0 .. e - 1 )
        {
            printf("\n\t  At: %d",i);
            for( j : 0 .. N - 1 )
            {
                if
                :: G[i].membership[j] -> printf("\n\t    [\tTrue\t]");
                :: else               -> printf("\n\t    [\tFalse\t]");
                fi
            };
        }
        printf("\n");
    }
}


inline print_user_epochs()
{
    d_step {
        printf("\n\tEpoch observing:");
        for ( i : 0 .. N - 1)
        {
            if
            :: ep[i] == NONE -> printf("\n\t    [\tNONE\t]")
            :: else          -> printf("\n\t    [\t%d\t]", ep[i])
            fi
        }
        printf("\n");
    }
}


inline print_user_hoarding()
{
    d_step {
        printf("\n\tHoarding since:");
        for ( i : 0 .. N - 1)
        {
            if
            :: D[i] == NONE -> printf("\n\t    [\tNONE\t]")
            :: else         -> printf("\n\t    [\t%d\t]", D[i])
            fi
        }
        printf("\n");
    }
}


inline print_user_unsafe()
{
    d_step {
        printf("\n\tRequired healing:");
        for ( i : 0 .. N - 1)
        {
            if
            :: unsafe[i] -> printf("\n\t    [\tTrue\t]");
            :: else      -> printf("\n\t    [\tFalse\t]");
            fi
        }
        printf("\n");
    }
}


inline print_user_messages()
{
    d_step {
        printf("\n\tMessages available:");
        for ( i : 0 .. N - 1)
        {
            if
            :: nempty( M[i] ) -> printf("\n\t    [\tTrue\t]");
            ::  empty( M[i] ) -> printf("\n\t    [\tFalse\t]");
            fi
        }
        printf("\n");
    }
}


inline print_attacker_knowledge()
{
    d_step
    {
        printf("\n\tAttacker Knowledge:");
        for( t : 0 .. T - 1 )
        {
            printf("\n>>> %d vvv", t);
            for( i : 0 .. TREE - 1 )
            {
                if
                :: attackerKnowledge[t].node[i] == UnknownRefs -> printf("\n\t%d [ x ]", i)
                :: attackerKnowledge[t].node[i] == UnknownNode -> printf("\n\t%d [ X ]", i)
                :: attackerKnowledge[t].node[i] ==   KnownRefs -> printf("\n\t%d [ o ]", i)
                :: attackerKnowledge[t].node[i] ==   KnownNode -> printf("\n\t%d [ O ]", i)
                :: else                                        -> printf("\n\t%d [   ]", i)
                fi
            }
        };
        printf("\n");
    }
}

inline print_global_state()
{
    d_step
    {
        printf("\n-=-=-=-=-=-=-=-=-=-=-=-\n-=-  GLOBAL  STATE  -=-\n-=-=-=-=-=-=-=-=-=-=-=-\n");
        print_challenges()
        print_leadership()
        print_membership()
        print_user_epochs()
        print_user_hoarding()
        print_user_messages()
        print_user_unsafe()
        print_attacker_knowledge()
    }
}

/********
    *
    * Inline utilities:
    *
    *   - Select Attendee
    *   - Select Absentee
    *   - Select byte
    *
********/


/****
  * External result variable(s):
  *   - groupFull
****/
inline group_full( input )
{   d_step {

    take_attendance( input )
    groupFull = absentees == 0;

}   }


/****
  * External result variable(s):
  *   - groupDyad
****/
inline group_dyad( input )
{   d_step {

    take_attendance( input )
    groupDyad = attendees == 2;

}   }


/****
  * External result variable(s):
  *   - unsafeIDs
****/
inline safety_poll()
{
    d_step {
        byte recoveriesRequired = 0;
        for ( i : 0 .. N - 1 ) {
            if
            :: unsafe[i] -> recoveriesRequired++;
            :: else
            fi
        }
        unsafeIDs = recoveriesRequired;
    }
}


/****
  * External result variable(s):
  *   - absentees
  *   - attendees
****/
inline take_attendance( t )
{   d_step {

    byte included = 0;
    byte e_i = lead[t];
    
    for ( i : 0 .. N - 1 ) {
         if
         :: G[t].membership[i] -> included++
         :: else
         fi
    }
    attendees = included;
    absentees = N - attendees;

}   }


/****
  * External result variable(s):
  *   - selectedID
****/
inline select_absentee( t )
{   atomic {

    byte sample;
    byte selection = NONE;
    byte ref = lead[t]

    take_attendance( t );
    select( sample : 0 .. absentees - 1 );

/*
    printf("\nSELECTING ABSENTEE:\n");
    printf("  attendees           = %d\n", attendees);
    printf("  absentees           = %d\n", absentees);
    printf("  sample              = %d\n", sample);
*/

    for ( i : 0 .. N - 1 ) {
//        printf("  i = %d v = %d s = %d g = %d\n", i, selection, sample, selection == NONE && G[t].membership[i]);
        if
        :: selection == NONE && !G[t].membership[i] && sample != 0 -> sample--
        :: selection == NONE && !G[t].membership[i] && sample == 0 -> selection = i
        :: else
        fi
    }

    selectedID = selection;
//    printf("  selection           = %d\n", selectedID);

}   }


/****
  * External result variable(s):
  *   - senderID
****/
inline select_sender( t )
{
    byte selectedID;
    select_sender_constrained( t, NONE, false );
    senderID = selectedID;
}


/****
  * External result variable(s):
  *   - exiledID
  *
****/
inline select_exiled( t, forced )
{
    byte selectedID;
    select_sender_constrained( t, NONE, forced );
    exiledID = selectedID;
}


/****
  * External result variable(s):
  *   - banisherID
****/
inline select_banisher( t, banned )
{
    byte selectedID;
    select_sender_constrained( t, banned, false );
    banisherID = selectedID;
}


/****
  * External result variable(s):
  *   - updaterID
****/
inline select_updater( t, forced )
{
    byte selectedID;
    select_sender_constrained( t, NONE, forced );
    updaterID = selectedID;
}



/****
  * External result variable(s):
  *   - selectedID
****/
inline select_sender_constrained ( t, banned, forced )
{ atomic {
    byte candidates = 0;
    d_step {
        for ( i : 0 .. N - 1 ) {
             if
             :: G[t].membership[i] && ep[i] == t && i != banned && (!(forced) || unsafe[i]) -> candidates++
             :: else
             fi
        }
    }

    byte sample;
    select( sample : 0 .. candidates - 1 );
    byte selection = NONE;
    d_step
    {
/**/
        printf("\nSELECTING Sender %d %d %d", t, banned, forced);
        printf("\n  candidates         = %d", candidates);
        printf("\n  sample             = %d", sample);
/**/

        for ( i : 0 .. N - 1 ) {
            printf("\n\ti = %d v = %d s = %d b = %d", i, selection, sample, G[t].membership[i] && ep[i] == t && i != banned && (!(forced) || unsafe[i]));
            if
            :: selection == NONE ->
                if
                ::  G[t].membership[i] && ep[i] == t && i != banned && (!(forced) || unsafe[i]) ->
                    if
                    :: sample == 0 -> selection = i
                    :: sample != 0 -> sample--
                    fi
                :: else
                fi
            :: else
            fi
        }
        printf("  selection           = %d\n", selection);

    }
    selectedID = selection;
}   }



/****
  * External result variable(s):
  *   - joinerID
****/
inline select_joiner( input )
{
    d_step
    {
        byte selectedID;
        select_absentee( input );
        joinerID = selectedID;
    }
}


/****
  * External result variable(s):
  *   - corruptedID
****/
inline select_corrupted( t )
{   atomic {

    byte selection = NONE;
    safety_poll();

    byte remainingEpochs = T - t - 1

    if
    :: unsafeIDs < T - t - 1 ->
        byte candidateMembers = 0;
        d_step
        {
            for ( i : 0 .. N - 1 )
            {   // The corrupted user must not previously been instructed to hoard!
                // Violates the "Safety Predicate SAFE" described in Alwen 2020.
                if
                :: D[i] == NONE &&
                   G[ep[i]].membership[i] &&
                   attackerKnowledge[ep[i]].node[NODE+i] == UnknownNode -> candidateMembers++
                :: else
                fi
            }
        }
        if
        :: candidateMembers > 0 ->
            byte sample;
            select ( sample : 0 .. candidateMembers - 1 );
            for ( i : 0 .. N )
            {
                if
                :: selection == NONE ->
                    if
                    :: D[i] == NONE && G[ep[i]].membership[i] && attackerKnowledge[ep[i]].node[NODE+i] == UnknownNode ->
                        if
                        :: sample == 0 -> selection = i
                        :: sample != 0 -> sample--
                        fi
                    :: else
                    fi
                :: else
                fi
            }
        :: else
        fi
    :: else
    fi
    corruptedID = selection

}   }


/****
  * External result variable(s):
  *   - currentEpoch
****/
inline current_epoch()
{   d_step {

    byte x = 0;
    for ( i : 0 .. T - 1 )
    {
        if
        :: lead[i] != NONE -> x++
        :: else
        fi
    }
    currentEpoch = x - 1;

}   }


/****
  * External result variable(s):
  *   - selectedEpoch
****/
inline select_epoch( input )
{   atomic {

    byte anyEpoch;
    select ( anyEpoch : 0 .. input );
    selectedEpoch = anyEpoch;

}   }


/****
  * External result variable(s):
  *   - revelationEpoch
****/
inline select_revelation( t )
{   atomic {

    byte candidateEpochs = 0
    byte challengesUsed  = 0
    d_step
    {
        for ( i : 0 .. t )
        {
            if
            ::  chall[i] -> challengesUsed++
//            :: !chall[i] && attackerKnowledge[i].node[ROOT] != KnownNode -> candidateEpochs++
            :: !chall[i] && attackerKnowledge[i].node[ROOT] == UnknownNode -> candidateEpochs++
            ::  else
            fi
        }
    }
    
    if
    :: candidateEpochs == 0 || challengesUsed >= C -> revelationEpoch = NONE
    :: else ->
        byte sample;
        select ( sample : 0 .. candidateEpochs - 1 );
        byte selection = NONE;
        d_step
        {
            for ( i : 0 .. t )
            {
                if
                :: selection == NONE ->
                    if
                    :: !chall[i] && attackerKnowledge[i].node[ROOT] == UnknownNode ->
                        if
                        :: sample == 0 -> selection = i
                        :: sample != 0 -> sample--
                        fi
                    :: else
                    fi
                :: else
                fi
            }
        }
        revelationEpoch = selection
    fi
}   }


/****
  * External result variable(s):
  *   - hoarderID
****/
inline select_hoarder( t )
{   atomic {

    byte id  = lead[t];

    byte candidateMembers = 0
    for ( i : 0 .. N - 1 )
    {
        if
        :: D[i] == NONE && G[ep[i]].membership[i] -> candidateMembers++
        :: else -> skip
        fi
    }

    byte selection = NONE;
    if
    :: candidateMembers > 0 ->
        byte sample;
        select ( sample : 0 .. candidateMembers - 1 );
        for ( i : 0 .. N - 1 )
        {
            if
            :: sample == 0 && selection == NONE && D[i] == NONE -> selection = i
            :: sample != 0 && selection == NONE && D[i] == NONE -> sample--
            :: else -> skip
            fi
        }
    :: else -> skip
    fi

    hoarderID = selection

}   }


/****
  * External result variable(s):
  *   - messagePending
  *   - messageVacancy
****/
inline message_status()
{   d_step {

//    printf("\nCHECKING AVAILABLE MESSAGES:\n");
    byte pending = false;
    bool vacancy = true;
    for ( i : 0 .. N - 1 )
    {
        pending = pending || nempty( M[i] );
        vacancy = vacancy &&  nfull( M[i] );
    }
    messagePending = pending;
    messageVacancy = vacancy;
}   }


/****
  * External result variable(s):
  *   - recipientID
****/
inline select_recipient()
{   atomic {

//    printf("\nSELECT RECIPIENT:\n");

    byte availableRecipient = 0;
    for ( i : 0 .. N - 1 )
    {
        if
        :: nempty(M[i]) -> availableRecipient++
        ::  empty(M[i]) -> skip
        fi
    }

//    printf("\nAvailable Recipients: %d\n", availableRecipient);

    byte sample;
    select( sample : 0 .. availableRecipient - 1 )

//    printf("\nSample: %d\n", sample);

    bool noContent;
    byte selection = NONE;
    for ( i : 0 .. N - 1 )
    {
        noContent = empty( M[i] );
//        printf("\n  i: %d  v: %d  s: %d  q: %d\n", i, selection, sample, content);
        if
        :: selection != NONE || noContent -> skip
        :: else ->
            if
            :: sample == 0 -> selection = i
            :: sample != 0 -> sample--
            fi
        fi
    }
    
//    printf("\nRecipient: %d\n", selection);
    recipientID = selection;

}   }


/****
  * External result variable(s):
  *   - forcedPlay
****/
inline forced_play( t ) {
    d_step {
        byte remainingEpochs = T - t - 1;
        safety_poll();
        assert( T - t - 1 >= unsafeIDs );
        forcedPlay = unsafeIDs > 0 && unsafeIDs == remainingEpochs;
    }
}


/****
  * External result variable(s):
  *   - commitEpochAdvance
****/
inline decide_commitment()
{
    do
    :: commitEpochAdvance = true;  break
//    :: commitEpochAdvance = false; break
    od
}


/****
  *
  * The following methods:
  *   - broadcast
  *   - propogate
  *
  * Are used by the security game moves:
  *   - insert_member
  *   - remove_member
  *   - oblige_update
  *
****/


inline broadcast ( t, sender, commitment, message )
{   atomic {

    // Attacker observes network messages
    attacker_observes_message( t, sender, commitment, message );
    
    if
    :: commitment ->
        for ( i : 0 .. N - 1 ) {
            if
            :: G[t].membership[i] -> M[i] ! t, sender;
            :: else
            fi
        };
        convey_update( sender )
    :: else
    fi

}   }


inline attacker_observes_message( t, sender, commitment, message )
{
    if
    :: !commitment -> skip
    :: else ->
        // If the attacker has know knowledge of the epoch,
        // then it is the first time we have entered the epoch
        // and the cell values should be initialized as either:
        //   * UnknownNode
        //   * UnknownRefs
        //   *        Void
        bool noEpochKnowledge;
        attacker_has_no_epoch_knowledge( t );
        if
        :: noEpochKnowledge -> attacker_init_epoch_knowledge( t );
        :: else
        fi
        
        //   referenceEpoch = (t == 0) ? t : t - 1;
        byte referenceEpoch = t ;
        if
        :: t != 0 -> referenceEpoch--;
        :: else
        fi

        attacker_copy_epoch_knowledge( referenceEpoch );
        attacker_wipe_sender_knowledge( sender, t );
        attacker_updates_knowledge ( t );
    fi
}



inline attacker_has_no_epoch_knowledge ( e )
{
    d_step
    {
        bool allVoid = true;
        for ( i : 0 .. TREE - 1 )
        {
            allVoid = allVoid && attackerKnowledge[e].node[i] == Void
        }
        noEpochKnowledge = allVoid;
    }
}


inline attacker_init_epoch_knowledge( e )
{   atomic {

    bool leaves = true;
    byte offset = NODE;
    byte width  = TREE + 1;
    do
    :: width == 0 -> break
    :: width != 0 -> d_step
        {
            width = width / 2;
            for ( i : 0 .. width - 1 )
            {
                j = offset + i;
                // Leaf node case(s)
                if
                :: leaves ->
                    if
                    // No knowledge from excluded group members
                    :: !G[e].membership[i] -> attackerKnowledge[e].node[j] = Void
                    :: else                -> attackerKnowledge[e].node[j] = UnknownNode
                    fi
                // Internal node case(s)
                :: else ->
                    byte childL = j * 2 + 1;
                    byte childR = j * 2 + 2;
                    // Check current epoch for existance of subtrees
                    bool existanceOfSubtree;
                    existance_of_subtree( e, childL);
                    bool voidL = !existanceOfSubtree;
                    existance_of_subtree( e, childR);
                    bool voidR = !existanceOfSubtree;
                    if
                    ::  voidL &&  voidR -> attackerKnowledge[e].node[j] =        Void
                    :: !voidL &&  voidR -> attackerKnowledge[e].node[j] = UnknownRefs
                    ::  voidL && !voidR -> attackerKnowledge[e].node[j] = UnknownRefs
                    :: !voidL && !voidR -> attackerKnowledge[e].node[j] = UnknownNode
                    fi
                fi
            };
            offset = offset / 2;
            leaves = false;
        }
    od
}   }


inline attacker_copy_epoch_knowledge( e )
{   atomic {

    byte offset = NODE;
    byte width  = TREE + 1;
    do
    :: width == 0 -> break
    :: width != 0 -> d_step
        {
            width = width / 2;
            for ( i : 0 .. width - 1 )
            {
                j = offset + i;
                bool knowledgeOfSubtree;
                knowledge_of_subtree( e, j);
                if
                ::  attackerKnowledge[e+1].node[j] == UnknownNode && knowledgeOfSubtree ->
                    attackerKnowledge[e+1].node[j] = KnownNode
                ::  attackerKnowledge[e+1].node[j] == UnknownRefs && knowledgeOfSubtree ->
                    attackerKnowledge[e+1].node[j] = KnownRefs
                :: else
                fi
            };
            offset = offset / 2;
        }
    od
}   }


inline attacker_wipe_sender_knowledge( sender, e )
{   atomic {

    byte offset = NODE;
    byte width  = TREE + 1;
    do
    :: width == 0 -> break
    :: width != 0 -> d_step
        {
            width = width / 2;
            j = offset + sender;
            if
            ::  attackerKnowledge[e].node[j] == UnknownNode ||
                attackerKnowledge[e].node[j] ==   KnownNode ->
                attackerKnowledge[e].node[j] =  UnknownNode
            ::  attackerKnowledge[e].node[j] == UnknownRefs ||
                attackerKnowledge[e].node[j] ==   KnownRefs ->
                attackerKnowledge[e].node[j] =  UnknownRefs
            :: else
            fi
            offset = offset / 2;
        }
    od
}   }


inline attacker_updates_knowledge( e )
{   atomic {

    bool leaves = true;
    byte offset = NODE;
    byte width  = TREE + 1;
    do
    :: width == 0 -> break
    :: width != 0 -> d_step
        {
            width = width / 2;
            for ( i : 0 .. width - 1 )
            {
                j = offset + i;
                if
                :: leaves -> skip
                :: else ->
                    byte childL = j * 2 + 1;
                    byte childR = j * 2 + 2;
                    // Check current epoch for existance of subtrees
                    bool existanceOfSubtree;
                    existance_of_subtree( e, childL);
                    bool voidL = !existanceOfSubtree;
                    existance_of_subtree( e, childR);
                    bool voidR = !existanceOfSubtree;
                    // Check previous epoch for knowledge of subtrees
                    bool knowledgeOfSubtree;
                    knowledge_of_subtree( e, childL);
                    bool knowsL = knowledgeOfSubtree;
                    knowledge_of_subtree( e, childR);
                    bool knowsR = knowledgeOfSubtree;
                    
                    if
                    ::  voidL &&  voidR                       -> attackerKnowledge[e].node[j] =        Void
                    :: !voidL &&  voidR &&             knowsR -> attackerKnowledge[e].node[j] =   KnownRefs
                    :: !voidL &&  voidR &&            !knowsR -> attackerKnowledge[e].node[j] = UnknownRefs
                    ::  voidL && !voidR &&  knowsL            -> attackerKnowledge[e].node[j] =   KnownRefs
                    ::  voidL && !voidR && !knowsL            -> attackerKnowledge[e].node[j] = UnknownRefs
                    :: !voidL && !voidR &&  knowsL &&  knowsR -> attackerKnowledge[e].node[j] =   KnownNode
                    :: !voidL && !voidR && !knowsL &&  knowsR -> attackerKnowledge[e].node[j] =   KnownNode
                    :: !voidL && !voidR &&  knowsL && !knowsR -> attackerKnowledge[e].node[j] =   KnownNode
                    :: !voidL && !voidR && !knowsL && !knowsR -> attackerKnowledge[e].node[j] = UnknownNode
                    fi
                fi
            };
            offset = offset / 2;
            leaves = false;
        }
    od
    }
}


inline existance_of_subtree( i, j )
{
    existanceOfSubtree = attackerKnowledge[i].node[j] != Void
}


inline knowledge_of_subtree( i, j )
{
    knowledgeOfSubtree = attackerKnowledge[i].node[j] == KnownNode || attackerKnowledge[i].node[j] == KnownRefs
}


inline propogate ( t, sender, insert, remove )
{
    d_step {
        for ( i : 0 .. N - 1 )
        {
            G[t+1].membership[i] = G[t].membership[i]
        }
        if
        :: insert != NONE -> G[t+1].membership[insert] = true
        :: remove != NONE -> G[t+1].membership[remove] = false
        :: else
        fi
    }
}


/********
    *
    * Oracles available to the attacker:
    *
    *   - Corrupt
    *   - Hoard
    *   - Reveal
    *
********/


inline corrupt( memberID )
{   atomic {

    // Learn the secret material of the user in their current epoch
    byte upperBound = ep[memberID];
//    attackerKnowledge[e].node[NODE+memberID] = KnownNode;

    byte lowerBound = upperBound;
    
    // Learn any additional secrets they have hoarded!
    byte epochSavedFrom = D[memberID];
    if
    :: epochSavedFrom < upperBound -> lowerBound = epochSavedFrom
    :: else
    fi

    printf("Corrupting from: %d -- %d\n", lowerBound, upperBound);

    // For each epoch which the member has secrets
    // (this implies that the user was a member)
    // Then the attacker learns the secrets on the direct path
    // between the member and the root node on the LBBT.
    byte peek;
    for ( peek : lowerBound .. upperBound )
    {
        printf("Corrupting %d\n", peek);
        if
        :: !G[peek].membership[memberID] -> skip
        :: else ->
            printf("Passed membership guard!\n");
            byte off   = NODE;
            byte level = TREE + 1;
            do
            :: level == 0 -> break
            :: level != 0 -> d_step
                {
                    level = level / 2;
                    k = off+memberID;
                    printf("tree level: %d @ %d\n", level, j);
                    if
                    :: attackerKnowledge[peek].node[k] == UnknownNode -> attackerKnowledge[peek].node[k] = KnownNode
                    :: attackerKnowledge[peek].node[k] == UnknownRefs -> attackerKnowledge[peek].node[k] = KnownRefs
                    :: else
                    fi
                    off = off / 2;
                }
                printf("Check Index Post: %d\n", peek);
                if
                :: i == upperBound ->
                    printf("UPPER BOUNDed %d\n", peek);
                    attacker_updates_knowledge( peek );
                :: else ->
                    printf("Lower Pre %d\n", peek);
                    attacker_copy_epoch_knowledge( peek  );
                    printf("Lower Post %d\n", peek);
                    attacker_updates_knowledge(   peek+1 );
                fi
                printf("Before hand off: %d\n", peek);
            od
        fi
    }

    unsafe[memberID] = true;
}   }


inline hoard( memberID )
{
    D[memberID] = ep[memberID]
}


inline reveal( t )
{
    d_step {
        chall[t] = true;
        attackerKnowledge[t].node[ROOT] -> KnownNode;
    }
}


/********
    *
    * Oracles available to the Group Members:
    *
    *   - Insert Member ( ADD )
    *   - Remove Member ( RMV )
    *   - Oblige Update ( UPD )
    *   - Convey Update ( DLV )
    *
********/


// Precondition: joiner is not in the group!
inline insert_member( t, sender, joiner, commitment )
{
    d_step {
//        printf("\nINSERT MEMBER:\n  Inviter: %d\n  joiner: %d\n  Epoch: \t%d\n", sender, joiner, t)
        assert(sender < N);
        assert(joiner < N);
    }
    if
    :: commitment -> propogate ( t, sender, joiner, NONE );
    :: else
    fi
    broadcast( t+1, sender, commitment, ADD );
}


// Precondition: exiledMemeber is in the group!
inline remove_member( t, sender, exiled, commitment )
{
    d_step {
        printf("\nREMOVE MEMBER:\n  Sender: \t%d\n  Exiled: \t%d\n  Epoch: \t%d\n", sender, exiled, t);
        assert(sender < N);
        assert(exiled < N);
        propogate ( t, sender, NONE, exiled);
        unsafe[exiled] = false;
    }
    broadcast( t+1, sender, commitment, RMV );
}


inline oblige_update( t, sender, commitment )
{
    d_step {
//        printf("\nOBLIGE UPDATE:\n  Sender: \t%d\n  Epoch: \t%d\n", sender, t);
        assert(sender < N);
        propogate ( t, sender, NONE, NONE );
        unsafe[sender] = false;
    }
    broadcast( t+1, sender, commitment, UPD );
}


inline convey_update( receiver )
{   atomic {
    byte e, s;
    printf("\nUPDATING: %d\n", receiver);
    M[receiver] ? e, s;

    d_step
    {
        ep[receiver] = e
        if
        :: lead[e] == NONE -> lead[e] = receiver;
        :: else
        fi
    }

}   }


inline initialize_attacker_knowledge()
{
    d_step
    {
        for( i : 0 .. T - 1 )
        {
            for( j : 0 .. TREE - 1 )
            {
                attackerKnowledge[i].node[j] = Void
            }
        }
    }
}


/********
    *
    * Initialization inline routines, in order of execution:
    *
    *   - Initialize
    *   - Select Group
    *   - Create Group
    *   - CGKA Security Game
    *
********/


inline CGKA_initialize()
{   atomic {
    printf("\n***********************\n* CGKA: Initialize!   *\n***********************\n");

    d_step
    {
        for( i : 0 .. N - 1 )
        {
            ep[i] = 0;
            D[i]  = NONE;
        };
    
        for( i : 0 .. T - 1 )
        {
            chall[i] = false;
            lead[i]  = NONE;
        };
    };

    endGame = false;

    initialize_attacker_knowledge()

}   }


inline CGKA_create_group()
{   atomic {
    printf("\n***********************\n* CGKA: Create Group! *\n***********************\n");

    byte id0, n, t;
    
    // Set the "lead" byte to be the first member in the group.
    d_step
    {
        id0 = 0;
        t   = 0;
        lead[t] = id0;
    }

    // Number of members to add
    select ( n : 2 .. N );
    for( i : 0 .. N - 1 )
    {
        G[t].membership[i] = i < n;
    };

    print_membership();
    
    broadcast ( t, id0, true, UPD );
    
    for( i : 1 .. N - 1 )
    {
        if
        :: G[t].membership[i] -> convey_update( i )
        :: else
        fi
    };

}   }


inline CGKA_security_game()
{
    printf("\n***********************\n* CGKA: Begin Play!   *\n***********************\n");
    endHere:
    do
    :: !endGame -> atomic
        {
            byte currentEpoch, revelationEpoch;
            bool forcedPlay, groupDyad, groupFull, messagePending, messageVacancy;
            byte corruptedID, exiledID, banisherID, hoarderID, updaterID;

            atomic
            {
//                printf("\nPRECOMPUTE GUARDS:\n");
    
                current_epoch();
                message_status();
                forced_play(       currentEpoch );
                group_dyad(        currentEpoch );
                group_full(        currentEpoch );
                select_revelation( currentEpoch );
                select_corrupted(  currentEpoch );
                select_hoarder(    currentEpoch );
                select_updater(    currentEpoch, forcedPlay );
                select_exiled(     currentEpoch, forcedPlay );
                select_banisher(   currentEpoch, exiledID   );
            };

            print_global_state()
/**/
            d_step
            {
                printf("\n\tforcedPlay  \t%d",  forcedPlay );
                printf("\n\tgroupDyad   \t%d",   groupDyad );
                printf("\n\tgroupFull   \t%d",   groupFull );
                printf("\n\tcorruptedID \t%d", corruptedID );
                printf("\n\texiledID    \t%d",    exiledID );
                printf("\n\tbanisherID  \t%d",  banisherID );
                printf("\n\thoarderID   \t%d",   hoarderID );
                printf("\n\tupdaterID   \t%d",   updaterID );
            }
/**/

            do
            /****************************************************
             *
             *  Corrupt
            **/
            :: corruptedID != NONE && !forcedPlay -> atomic
                {
                    printf("\n> > >\n> CGKA: Game Move = corrupt %d\n> > >\n", corruptedID);
                    corrupt( corruptedID )
                }; break
            /****************************************************
             *
             *  Hoard
            **/
            :: hoarderID != NONE -> atomic
                {
                    printf("\n> > >\n> CGKA: Game Move = hoard %d\n> > >\n", hoarderID);
                    hoard( hoarderID )
                }; break
            /****************************************************
             *
             *  Reveal
            **/
            :: revelationEpoch != NONE -> atomic
                {
                    printf("\n> > >\n> CGKA: Game Move = reveal %d\n> > >\n", revelationEpoch);
                    reveal( revelationEpoch )
                }; break
            /****************************************************
             *
             *  Convey
            **/
            :: messagePending -> atomic
                {   // Selection
                    byte recipientID;
                    select_recipient();
                    // Execution
                    printf("\n> > >\n> CGKA: Game Move = convey_update %d\n> > >\n", recipientID);
                    convey_update ( recipientID );
                }; break
            /****************************************************
             *
             *  Update
            **/
            :: messageVacancy && updaterID != NONE -> atomic
                {
                    bool commitEpochAdvance;
                    decide_commitment();
                    printf("\n> > >\n> CGKA: Game Move = oblige_update %d (committed? %d)\n> > >\n", updaterID, commitEpochAdvance);
                    oblige_update( currentEpoch, updaterID, commitEpochAdvance );
                }; break
            /****************************************************
             *
             *  Remove
            **/
            :: !groupDyad && messageVacancy && exiledID != NONE && banisherID != NONE -> atomic
                {
                    bool commitEpochAdvance;
                    decide_commitment();
                    printf("\n> > >\n> CGKA: Game Move = remove_member %d %d (committed? %d)\n> > >\n", banisherID, exiledID, commitEpochAdvance);
                    remove_member( currentEpoch, banisherID, exiledID, commitEpochAdvance );
                }; break
            /****************************************************
             *
             *  Insert
            **/
            :: !groupFull && !forcedPlay && messageVacancy -> atomic
                {   // Selection
                    byte joinerID, senderID;
                    select_sender( currentEpoch );
                    select_joiner( currentEpoch );
                    bool commitEpochAdvance;
                    decide_commitment();
                    // Execution
                    printf("\n> > >\n> CGKA: Game Move = insert_member %d %d (committed? %d)\n> > >\n", senderID, joinerID, commitEpochAdvance);
                    insert_member( currentEpoch, senderID, joinerID, commitEpochAdvance );
                }; break
            od;

           /**
             *  Post game move update.
            **/
            d_step
            {
                // After the operation is complete, check to see if the an endgame condition has been reached.
                current_epoch();
                safety_poll();
                endGame = lead[T-1] != NONE && unsafeIDs == 0;
                printf ("\n< < <\n< Moves:   %d\n< Unsafe:  %d\n< Endgame: %d\n< < < \n", T - currentEpoch - 1, unsafeIDs, endGame);
            };
        }
    :: else -> break
    od   
}


inline CGKA_safety_check()
{
    printf("\n***********************\n* CGKA: Safety Check! *\n***********************\n");

    print_attacker_knowledge();
}


init
{
    CGKA_initialize();
    CGKA_create_group();
    CGKA_security_game();
    CGKA_safety_check();
}


//ltl end_game_implies_safety   { <>(endGame) }
ltl attendees_more_than_one   { [](attendees > 1) }
//ltl attendees_absentees_sum { [](attendees + absentees == N) }
