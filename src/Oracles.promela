/********
    *
    * Advantage:
    *
    * In the following, a (`t`, `c`, `n`)-attacker is an attacker `A` that runs in time at most `t`,
    * makes at most `c` challenge queries, and never produces a group with more than `n` members.
    * The attacker wins the CGKA security game if they correctly guesses the random bit `b` in
    * the end and the safety predicate `P` evaluates to true on the queries made by the attacker.
    *
    * Hence we define our (`t`, `c` `n`) constants below:
    *
********/

// A constant for missing data
#define NONE 255

// Security parameters of the game
#define T  3
#define C 12
#define N  4

/****
  *
  * Special types required for the protocol.
  *
****/

mtype:Secret = { Empty, Known, Unknown };

typedef Membership { bool         membership[N] };
typedef Group      { Membership   reference[N]  };
typedef Enigma     { mtype:Secret secret[T]     };


/****
  *
  * Global state of the CGKA security game.
  *
****/

byte    lead[T];
Group      G[T];
bool   chall[T]; // Has the attacker challenged in an epoch?
Enigma        I; // Root node secrets over epochs

Enigma gamma[N]; // User state
byte      ep[N]; // The epoch of each user.
bool       D[N]; // Does the user delete old secrets?

// Epoch, Sender, Welcome?, Transform?
chan M[N] = [2] of { byte, byte, bool, bool };


/****
  *
  * Global constants for comparison.
  *
****/

byte Unspecified    = NONE; // Epoch leader ID for epochs which have not elapsed in "lead"
byte NonParticipant = NONE; // Denotation for a user who is not a member during an epoch in "ep"


/****
  *
  * Global (local) variable for inline functions.
  *
****/

local byte i = 0
local byte j = 0;
local byte absentees = 0;
local byte attendees = N;


/*
bool knowledge[2 * N - 1];

     vvv   KNOWLEDGE BITS    vvv

           +----(14)----+
          /              \
        (12)             (13)
       /   \            /    \
    (8)     (9)      (10)     (11)
   /   \   /   \    /    \   /    \
  0     1 2     3  4      5 6      7

     ^^^   MEMBERSHIP BITS   ^^^
*/


/********
    *
    * Inline utilities:
    *
    *   - Select Attendee
    *   - Select Absentee
    *   - Select byte
    *
********/


/****
  * External result variable(s):
  *   - groupFull
****/
inline group_full( input )
{   d_step {

    take_attendance( input )
    groupFull = absentees == 0;

}   }


/****
  * External result variable(s):
  *   - groupDyad
****/
inline group_dyad( input )
{   d_step {

    take_attendance( input )
    groupDyad = attendees == 2;

}   }


/****
  * External result variable(s):
  *   - queueFull
****/
inline queue_full()
{   d_step {

    bool found = false
    for( i : 0 .. N - 1 )
    {
        if
        :: full( M[i] ) -> found = true
        :: else -> skip
        fi
    }

}   }


/****
  * External result variable(s):
  *   - absentees
  *   - attendees
****/
inline take_attendance( input )
{   d_step {

    byte included = 0;
    byte e_i = lead[input];
    
    for ( i : 0 .. N - 1 ) {
         if
         :: G[input].reference[e_i].membership[i] -> included++
         :: else -> skip
         fi
    }
    attendees = included;
    absentees = N - attendees;

}   }


/****
  * External result variable(s):
  *   - selectedID
****/
inline select_attendee( input )
{   atomic {

    byte bound, sample;
    byte selection = NONE;
    byte ref = lead[input]

    take_attendance( input );

    select( sample : 0 .. attendees - 1 );
    
    printf("\nSELECTING ATTENDEE:\n");
    printf("  attendees           = %d\n", attendees);
    printf("  absentees           = %d\n", absentees);
    printf("  sample              = %d\n", sample);

    for ( i : 0 .. N - 1 ) {
        printf("  i = %d v = %d s = %d g = %d\n", i, selection, sample, selection == NONE && G[input].reference[ref].membership[i]);
        if
        :: selection == NONE && G[input].reference[ref].membership[i] && sample != 0 -> sample--
        :: selection == NONE && G[input].reference[ref].membership[i] && sample == 0 -> selection = i
        :: else -> skip;
        fi
    }

    selectedID = selection;
    printf("  selection           = %d\n", selectedID);

}   }


/****
  * External result variable(s):
  *   - selectedID
****/
inline select_absentee( input )
{   atomic {

    byte sample;
    byte selection = NONE;
    byte ref = lead[input]

    take_attendance( input );
    select( sample : 0 .. absentees - 1 );

    printf("\nSELECTING ABSENTEE:\n");
    printf("  attendees           = %d\n", attendees);
    printf("  absentees           = %d\n", absentees);
    printf("  sample              = %d\n", sample);

    for ( i : 0 .. N - 1 ) {
        printf("  i = %d v = %d s = %d g = %d\n", i, selection, sample, selection == NONE && G[input].reference[ref].membership[i]);
        if
        :: selection == NONE && !G[input].reference[ref].membership[i] && sample != 0 -> sample--
        :: selection == NONE && !G[input].reference[ref].membership[i] && sample == 0 -> selection = i
        :: else -> skip;
        fi
    }

    selectedID = selection;
    printf("  selection           = %d\n", selectedID);

}   }


/****
  * External result variable(s):
  *   - senderID
****/
inline select_sender( input )
{   d_step {

    byte selectedID;
    select_attendee( input );
    senderID = selectedID;
    printf("\nSelect Sender: %d\n", senderID)

}   }


/****
  * External result variable(s):
  *   - exiledID
  *
  * Similar to select_attendee
****/
inline select_exiled( banisher )
{   atomic {

    byte sample;
    byte selection = NONE;
    byte targets = 0;
    byte t   = ep[banisher];
    byte ref = banisher;
    
    for ( i : 0 .. N - 1 ) {
         if
         :: i != ref && G[t].reference[ref].membership[i] -> targets++
         :: else -> skip
         fi
    }

    select( sample : 0 .. targets - 1 );

    printf("\nSELECTING EXILE:\n");
    printf("  included           = %d\n", attendees);
    printf("  sample             = %d\n", sample);

    for ( i : 0 .. N - 1 ) {
        printf("  i = %d v = %d s = %d g = %d\n", i, selection, sample, selection == NONE && G[t].reference[ref].membership[i]);
        if
        :: ref == i -> skip; // Don't remove yourself
        :: selection == NONE && G[t].reference[ref].membership[i] && sample != 0 -> sample--
        :: selection == NONE && G[t].reference[ref].membership[i] && sample == 0 -> selection = i
        :: else -> skip;
        fi
    }

    exiledID = selection;
    printf("  selection          = %d\n", exiledID);

}   }


/****
  * External result variable(s):
  *   - joinerID
****/
inline select_joiner( input )
{   d_step {

    byte selectedID;
    select_absentee( input );
    joinerID = selectedID;
    printf("\nSelect Joiner: %d\n", joinerID)

}   }


/****
  * External result variable(s):
  *   - currentEpoch
****/
inline current_epoch()
{   d_step {

    byte x = 0;
    for ( i : 0 .. T - 1 )
    {
        if
        :: I.secret[i] != Empty -> x++
        :: else                 -> skip
        fi
    }
    currentEpoch = x - 1;

}   }


/****
  * External result variable(s):
  *   - selectedEpoch
****/
inline select_epoch( input )
{   atomic {

    byte anyEpoch;
    select ( anyEpoch : 0 .. input );
    selectedEpoch = anyEpoch;

}   }


/****
  * External result variable(s):
  *   - messagePending
  *   - messageVacancy
****/
inline message_status()
{   d_step {

    printf("\nCHECKING AVAILABLE MESSAGES:\n");
    byte pending = false;
    bool vacancy = true;
    for ( i : 0 .. N - 1 )
    {
        pending = pending || nempty( M[i] );
        vacancy = vacancy &&  nfull( M[i] );
    }
    messagePending = pending;
    messageVacancy = vacancy;
}   }


/****
  * External result variable(s):
  *   - recipientID
****/
inline select_recipient()
{   atomic {

    printf("\nSELECT RECIPIENT:\n");

    byte availableRecipient = 0;
    for ( i : 0 .. N - 1 )
    {
        if
        :: nempty(M[i]) -> availableRecipient++
        ::  empty(M[i]) -> skip
        fi
    }

    printf("\nAvailable Recipients: %d\n", availableRecipient);

    byte sample;
    select( sample : 0 .. availableRecipient - 1 )

    printf("\nSample: %d\n", sample);

    byte selection = NONE;
    bool content;
    for ( i : 0 .. N - 1 )
    {
        content =  nempty(M[i]);
        printf("\n  i: %d  v: %d  s: %d  q: %d\n", i, selection, sample, content);
        if
        :: selection == NONE && nempty( M[i] ) && sample == 0 -> selection = i
        :: selection == NONE && nempty( M[i] ) && sample != 0 -> sample--
        :: selection == NONE &&  empty( M[i] ) && sample == 0 -> skip
        :: selection != NONE -> skip
        fi
    }
    
    printf("\nRecipient: %d\n", selection);
    recipientID = selection;

}   }


/********
    *
    * Oracles available to the attacker:
    *
    *   - Corrupt
    *   - Hoard
    *   - Reveal
    *
********/


/*
D_proctype corrupt(ID input)
{   d_step {

    byte currentEpoch;
    current_epoch();

    gamma[input].secret[currentEpoch] = Known;

}   }


D_proctype hoard(ID input)
{   d_step {

    D[input] = false;

} }


D_proctype reveal(Epoch input)
{   d_step {

    byte t = input;
    if
    :: I.secret[t] == Empty || chall[t] -> skip;
    :: else ->
        chall[t] = true;
        I.secret[t] = Known;
    fi

} }


// Do I need this?
D_proctype challenge(Epoch input)
{   d_step {

    byte t = input;
    if
    :: I.secret[t] == Empty || chall[t] -> skip;
    :: else ->
        chall[t] = true;
        I.secret[t] = Known;
    fi

} }
*/


/********
    *
    * Oracles available to the Group Members:
    *
    *   - Insert Member ( ADD )
    *   - Remove Member ( RMV )
    *   - Oblige Update ( UPD )
    *   - Convey Update ( DLV )
    *
********/


/**/
// Precondition: joiningMember is not in the group!
inline insert_member( invitingMember, joiningMember )
{   atomic {

    byte t;
    
    d_step {

        printf("\nINSERT MEMBER:\n  Inviter: %d\n  joiner: %d\n", invitingMember, joiningMember)
    
        t = ep[invitingMember];
    
        printf("\nINSERT EPOCH:\n  Inviter: %d\n  byte: %d\n", invitingMember, t)
    
        gamma[invitingMember].secret[t+1] = Unknown;
    
        printf("\nINSERT MESSAGE:\n  Epoch:  \t %d\n  Inviter:\t %d\n  Joiner:\t %d\n  W:    \t %d\n  T:    \t %d\n", t+1, invitingMember, joiningMember, W1, U)
        assert(joiningMember < N);
    }
        
    M[joiningMember] ! t+1, invitingMember, true, true;
    
    d_step {

        for ( i : 0 .. N - 1 ) {
            G[t+1].reference[invitingMember].membership[i] = G[t].reference[invitingMember].membership[i]
        }
        G[t+1].reference[invitingMember].membership[joiningMember] = true
        
        for ( i : 0 .. N - 1 ) {
            if
            :: G[t].reference[invitingMember].membership[i] ->
                M[i] ! t+1, invitingMember, false, true;
            :: else -> skip;
            fi
        }
    }    
}   }
/**/


/**/
// Precondition: exiledMemeber is in the group!
inline remove_member( banisher, banishee )
{   atomic {

    byte t;

    d_step {
        t = ep[banisher];
        
        printf("\nREMOVE MEMBER:\n  Banisher: \t%d\n  Exile: \t%d\n  byte: \t%d\n", banisher, banishee, t);
    
        gamma[banisher].secret[t+1] = Unknown;
    
        for ( i : 0 .. N - 1 ) {
            if
            :: i == banishee ->
                G[t+1].reference[banisher].membership[i] = false;
//                ep[i] = NonParticipant
            :: else ->
                G[t+1].reference[banisher].membership[i] = G[t].reference[banisher].membership[i]
            fi
        }
    }    

    for ( i : 0 .. N - 1 ) {
        if
        :: G[t].reference[banisher].membership[i] ->
            M[i] ! t+1, banisher, false, true;
        :: else -> skip;
        fi
    }

}   }
/**/


inline member_update( receiver )
{   atomic {

    byte sender;
    byte t_i;
    bool W_i;
    bool U_i;

    printf("\nMEMBER UPDATE:\n  Target\t %d\n", receiver);

    M[receiver] ? t_i, sender, W_i, U_i;

    byte ref = receiver;
    d_step {
        printf("\nUPDATE MESSAGE:\n  Target\t %d\n  byte \t %d\n  Sender\t %d\n  Receiver\t %d\n", receiver, t_i, sender, receiver);
    
        gamma[ref].secret[t_i] = Unknown;
    
        if
        :: lead[t_i] == Unspecified ->
            lead[t_i] = sender;
            printf("SET lead[%d] <- %d\n", t_i, sender);
            I.secret[t_i] = Unknown;
        :: else -> skip
        fi
        ep[ ref]   = t_i;
    }
    
    for ( i : 0 .. N - 1 ) {
        G[t_i].reference[ref].membership[i] = G[t_i].reference[sender].membership[i]
    }
}   }


/********
    *
    * Initialization inline routines, in order of execution:
    *
    *   - Initialize
    *   - Select Group
    *   - Create Group
    *   - CGKA Security Game
    *
********/


inline CGKA_initialize()
{   atomic {

    for( i : 0 .. N - 1 )
    {
        ep[i] = 0;
        D[i]  = true;
        
        for( j : 0 .. T - 1 )
        {
            gamma[i].secret[j] = Unknown;
        }
    };

    for( i : 0 .. T - 1 )
    {
        chall[i]    = false;
        lead[i]     = Unspecified;
        I.secret[i] = Empty;
    }

}   }


inline CGKA_create_group()
{   atomic {

    // Set the "lead" byte to be the first member in the group.
    byte id0 = 0;
    byte t = 0;

    // Number of members to add
    byte n;
    select ( n : 2 .. N );
    printf("\nSELECTED n <- %d\n", n);
    
    for( i : 0 .. N - 1 )
    {
        G[t].reference[id0].membership[i] = i < n;
    };

    printf("\nINITIAL GROUP:");
    for( i : 0 .. N - 1 )
    {
        if
        :: G[t].reference[id0].membership[i] ->
             printf("\n  [ T ]");
        :: else ->
             printf("\n  [ F ]");
        fi
    }
    for( i : 0 .. N - 1 )
    {
        if
        ::  G[t].reference[id0].membership[i] ->
            M[i] ! t, id0, true, false;
            member_update( i )
        :: else -> skip
        fi
    }

}   }


inline CGKA_security_game()
{
    endHere:
    do
    :: I.secret[T-1] == Empty -> atomic
        {
            byte currentEpoch;
            bool groupDyad, groupFull, messagePending, messageVacancy;
     
            atomic {
                printf("\nPRECOMPUTE GUARDS:\n");
    
                current_epoch();
                printf("  currentEpoch   = %d\n", currentEpoch);
    
                message_status();
                printf("  messagePending = %d\n", messagePending);
                printf("  messageVacancy = %d\n", messageVacancy);
    
                group_dyad( currentEpoch );
                printf("  groupDyad      = %d\n", groupDyad);
    
                group_full( currentEpoch );
                printf("  groupFull      = %d\n", groupFull);
                printf("  absentees      = %d\n", absentees);
                printf("  attendees      = %d\n", attendees);
    
            };
    
            d_step {
                printf("\nPRINT GLOBAL STATE:\n");
    
                printf("\n  lead:\n    [ ");
                for ( i : 0 .. T - 1)
                {
                    if
                    :: i == 0 -> printf(  "%d ", lead[i])
                    :: i != 0 -> printf("| %d ", lead[i])
                    fi
                }
                printf("]\n");
    
                printf("\n  chall:\n    [ ");
                for ( i : 0 .. T - 1)
                {
                    if
                    :: i == 0 -> printf(  "%d ", chall[i])
                    :: i != 0 -> printf("| %d ", chall[i])
                    fi
                }
                printf("]\n");
    
                printf("\n  ep:\n    [ ");
                for ( i : 0 .. T - 1)
                {
                    if
                    :: i == 0 -> printf(  "%d ", ep[i])
                    :: i != 0 -> printf("| %d ", ep[i])
                    fi
                }
                printf("]\n");
    
                printf("\n  M:\n    [ ");
                for ( i : 0 .. N - 1)
                {
                    byte v = len(M[i]);
                    if
                    :: i == 0 -> printf(  "%d ", v)
                    :: i != 0 -> printf("| %d ", v)
                    fi
                }
                printf("]\n");
    
            };
    
            do
            // General options:
    /**/
            :: !groupDyad && messageVacancy -> atomic
                {
                    printf("\nBRANCHING: remove_member\n")
                    byte senderID, exiledID;
                    select_sender( currentEpoch );
                    select_exiled( senderID );
                    remove_member( senderID, exiledID );
                    member_update( senderID );
                }; break
    /**/
    /**/
            :: !groupFull && messageVacancy -> atomic
                {
                    printf("\nBRANCHING: insert_member\n")
                    byte senderID, joinerID;
                    select_sender( currentEpoch );
                    select_joiner( currentEpoch );
                    insert_member( senderID, joinerID );
                    member_update( senderID );
                }; break
    /**/
                
            :: messagePending -> atomic
                {
                    printf("\nBRANCHING: convey_update\n")
                    byte recipientID;
                    select_recipient();
                    member_update ( recipientID );
                }; break
    /*
            // Attacker Exclusive options:
            :: atomic
                {
                    byte selectedEpoch;
                    select_epoch( currentEpoch );
                    run corrupt( selectedEpoch );
                };
                break
    
            :: atomic
                {
                    
                    byte selectedID;
                    select_attendee( currentEpoch );
                    run hoard( selectedID );
                }; break
    
            :: atomic
                {
                    byte selectedID;
                    select_attendee( currentEpoch );
                    run reveal( selectedID );
                };
                break
    */
    //        :: else -> break
            od
        }
    :: else -> break
    od
}


init
{
    CGKA_initialize();
    CGKA_create_group();
    CGKA_security_game();
}

//ltl attendees_more_than_one { [](attendees > 1) }
ltl attendees_absentees_sum { [](attendees + absentees == N) }
