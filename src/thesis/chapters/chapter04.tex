\hypertarget{sec:model-encoding}{%
\chapter{Model Encoding}\label{sec:model-encoding}}

With the relationships of actors within the \CGKAsec formalized in Chapter \ref{sec:model-formalization}, a description of how the \CGKAsec is encoded into the \CGKAmod{P}{T}{N} is necissary for model justification.
The \CGKAmod{P}{T}{N} model encoding can be segmentented into three major components.
The top-most component, contains is the encoding of the model's globals state along with the model's initialization, control loop, and termination.
Second, there is the collection of oracles queried by the attacker.
Lastly, the polymorphic module \texttt{P} encapsulating and maintaining the attacker knowledgebase.


\hypertarget{sec:game-oracles}{%
\section{CGKA Game}\label{sec:game-oracles}}

A justifyable model of the \CGKAsec game requires a small core of global variables.
These variables, importantly, are the only mutable values which can be used within an \Abrev{LTL} predicate during verification.
The global state of mutates as the given permutation of protocol execution within the \CGKAsec is evaluated.
Initialization of the global variables occurs first, followed by the creation of the model's \texttt{CGKA} process.
The evolution of execution is guided by the main control loop within the \texttt{CGKA} process.


\hypertarget{subsec:global-state}{%
\subsection{Global State}\label{subsec:global-state}}

The global state variables of the \CGKAmod{P}{T}{N} are important to understand in detail.
Their importance follows from the fact that only global variable within the \CGKAmod{P}{T}{N} model can be referenced in the \Abrev{LTL} predicates.
Many of these global variables are directly dependent on parameters \(T\) and \(N\).
Notably, a series of ``C-like'' constant macro deinintions.
Theses constants are ``hard-coded'' when compiling a parameterized model, and referenced throughout the model's PROMELA encoding.

The constants are described in Table \ref{tab:constants-from-parameters} and depicted in Figure \ref{fig:Encoded-Constants}.
There are five broad categories of parameter-dependant constants, which are described in the same order in Table \ref{tab:constants-from-parameters}.

\begin{enumerate}
\item Security parameters
\item Bit widths
\item \Abrev{LBBT} topological layout information
\item Missing data ``sentinel values''
\item Inclusive bounds for looping over range of non-missing values
\end{enumerate}

The bit width constants are used to specify the width of PROMELA \texttt{unsigned} types used within the model encoding.
Generally, the unsigned types are represent either an epoch, a user ID, or a \Abrev{LBBT} vertex index.
When representing an epoch or user ID, one additional ``sentinel'' value is added to the reprsentation space, allowing for the absence of an epoch or user ID to be reprsented int he same type.
Careful consideration of PROMELA \texttt{unsigned} type's specifyied bit width must be taken into account when defining the representation.
For example \(N=7\) requires only 3 bits to represent all possible values \([0,7]\), but to represent a possibly missing user ID an extra value of \((7 + 1 = 8)\) is added to the range, and 4 bits are required to represent all posible user ID values in the range \([0,\, 8]\).

\begin{table}[h!]
  \centering
  \caption{\label{tab:constants-from-parameters} Derivation of \CGKAmod{P}{T}{N} model constants from \(T\) and \(N\).}
  \subimport{../tables/}{constants-from-parameters}
\end{table}
    
\begin{figure}[h!]
  \centering
  \caption{\label{fig:Encoded-Constants}\CGKAmod{}{}{} --- parameterized constants for \(T=12\) and \(N=8\).}
\begin{verbatim}
#define T 12
#define C 12
#define N 8
#define BITS_T 4
#define BITS_C 4
#define BITS_N 3
#define BITS_EPOCH  4
#define BITS_USERID 4
#define BITS_VERTEX 4
#define NEVER 15
#define NONE  15
#define TREE_ORDER 15
#define ROOT       0
#define LEAF       7
#define MAX_REVEAL 11
#define FIRST_EPOCH  0
#define FINAL_EPOCH  11
#define FIRST_USERID 0
#define FINAL_USERID 7
#define FIRST_VERTEX 0
#define FINAL_VERTEX 14
\end{verbatim}
\end{figure}

Global state variables differ from the constants bentioned above, as they are mutable and their values change throught the course of program execution.
The global variables for the \CGKAmod{P}{T}{N} are shown in Figure \ref{fig:Global-State}.
There are boolean array to track \Oracle{chall}{} queries, group membership, and group member ``saftey'' (corruption), as well as byte arrays representing epoch initiation and secret retention for each user.
The \texttt{unsigned} variable \texttt{epoch} stores the current epoch of the furthest advanced user ID within the \CGKAsec.
The \texttt{unsigned} variables \texttt{originID} and \texttt{targetID} store user IDs effected by current query to \Oracle{add-user}{}, \Oracle{remove-user}{}, or \Oracle{send-update}{}.
Including \texttt{originID} and \texttt{targetID} in the global state permits usage within \Abrev{LTL} predicates.


\begin{figure}[h!]
  \centering
  \caption{\label{fig:Global-State}\CGKAmod{}{}{} --- global state of the \CGKAsec.}
\begin{verbatim}
local bool  challenge[T]; // Has the attacker challenged in an epoch?
local byte leadership[T]; // Which member initiated the epoch?
local bool learnedKey[T]; // Attacker knows the group key of current epoch?

local bool membership[N]; // Group membership of current epoch
local byte   hoarding[N]; // Epoch from which the user saves secrets

local bool     unsafe[N];               // Members which require a change to update
local unsigned unsafeIDs : BITS_USERID; // Flags set within unsafe

local unsigned epoch     : BITS_EPOCH;  // The current epoch

local unsigned originID  : BITS_USERID; // ID of the  member
local unsigned targetID  : BITS_USERID; // ID of the effected member
\end{verbatim}
\end{figure}


\hypertarget{subsec:control-loop}{%
\subsection{Control Loop}\label{subsec:control-loop}}

The \CGKAmod{P}{T}{N} model transparently reflects the \CGKAsec operations and logic.
First the \CGKAmod{P}{T}{N} model is initialized via \texttt{CGKA\_initialize} as depicted in Figure \ref{fig:Control-Initialization}.
Next the first epoch, epoch \(0\), is initiated in a subsquent call to \texttt{CGKA\_create\_group}, shown in Figure \ref{fig:Control-Group-Creation}.
Finally, play nondeterministically progresses via the main control loop defined within \texttt{CGKA\_security\_game}, as illistrated by Figure \ref{fig:Control-Loop}.
Each loop iteration invokes either \texttt{play\_move\_with\_commitment} or \texttt{play\_move\_without\_commitment}, shown in Figures \ref{fig:Control-Commitment} and \ref{fig:Control-Noncommitment}, which advance play to the next epoch or remain in the same epoch respectively.

\begin{figure}[h!]
  \centering
  \caption{\label{fig:Control-Initialization}\CGKAmod{}{}{} --- initialization of model.}
\begin{verbatim}
inline CGKA_initialize()
{
    atomic {
    d_step
    {
        d_step
        {
            unsigned n : BITS_USERID;
            for ( n : FIRST_USERID .. FINAL_USERID )
            {
                hoarding[n] = NEVER;
            };
        };
        
        d_step
        {
            unsigned t : BITS_EPOCH;
            for ( t : FIRST_EPOCH .. FINAL_EPOCH )
            {
                challenge[t]  = false;
                leadership[t] = NONE;
            };
        };

        epoch     = 0;
        unsafeIDs = 0;

        attacker_initialize ( )
    };
    }
}
\end{verbatim}
\end{figure}


\begin{figure}[h!]
  \centering
  \caption{\label{fig:Control-Group-Creation}\CGKAmod{}{}{} --- initial group creation.}
\begin{verbatim}
inline CGKA_create_group ( )
{
    unsigned sample : BITS_USERID; // Number of members to add
    d_step 
    {
        select ( sample : 2 .. N );
        unsigned n      : BITS_USERID;
        for ( n : FIRST_USERID .. FINAL_USERID )
        {
            membership[n] = n < sample;
        };
    };

    d_step
    {
        unsigned id0 : BITS_USERID = 0;
        unsigned ep0 : BITS_EPOCH  = 0;
        messaging_move ( ep0, id0, NONE, NONE );
    }
}
\end{verbatim}
\end{figure}


\begin{figure}[h!]
  \centering
  \caption{\label{fig:Control-Loop}\CGKAmod{}{}{} --- main game loop.}
\begin{verbatim}
inline CGKA_security_game()
{
start_of_game:
  commitmentRequired = false;
  
  for ( epoch : 0 .. FINAL_EPOCH ) // Loop through all epochs
  {
start_of_epoch: skip
      do
      // 1. Play the Challenge Move
      :: epoch == FINAL_EPOCH -> break

progress_epoch:
      // 2. Play a Commitment Move
      :: epoch != FINAL_EPOCH -> play_move_with_commitment ( ); break

      // 3. Play a Non-commital Move
      :: !(commitmentRequired) -> play_move_without_commitment ( )
      od;
  }

end_of_game:
  d_step
  {
      epoch = FINAL_EPOCH;
      print_entire_state ( );
  }
}
\end{verbatim}
\end{figure}


\begin{figure}[h!]
  \centering
  \caption{\label{fig:Control-Commitment}\CGKAmod{}{}{} --- query which commits to next epoch.}
\begin{verbatim}
inline play_move_with_commitment ( )
{
    unsigned evictorID : BITS_USERID, 
             evicteeID : BITS_USERID, 
             inviteeID : BITS_USERID, 
             inviterID : BITS_USERID,
             updaterID : BITS_USERID;
    atomic
    {
        select_evictee ( );
        select_evictor ( evicteeID );
        select_invitee ( );
        select_inviter ( );
        select_updater ( );
    };

    if
    :: inviterID != NONE && inviteeID != NONE -> insert_member ( inviterID, inviteeID )
    :: evictorID != NONE && evicteeID != NONE -> remove_member ( evictorID, evicteeID )
    :: else                                   -> oblige_update ( updaterID            )
    fi

    post_play_poll ( epoch + 1 ); // Updates global state...
}
\end{verbatim}
\end{figure}

\begin{figure}[h!]
  \centering
  \caption{\label{fig:Control-Noncommitment}\CGKAmod{}{}{} --- query which remain in same epoch.}
\begin{verbatim}
inline play_move_without_commitment ( )
{
    unsigned corruptedID : BITS_USERID, 
               hoarderID : BITS_USERID;
    atomic
    {
        select_corrupted ( );
        select_hoarder   ( );
    };

    bool canReveal = epoch != FINAL_EPOCH && !(learnedKey[epoch]);

    if
    :: corruptedID != NONE -> corrupt ( corruptedID )
    :: hoarderID   != NONE -> hoard   (   hoarderID )
    :: canReveal           -> reveal  (             )
    fi

    post_play_poll ( epoch );  // Updates global state...
}
\end{verbatim}
\end{figure}


\hypertarget{sec:game-oracles}{%
\section{Oracles}\label{sec:game-oracles}}

The oracles of the \CGKAsec are replicated within the \CGKAmod{P}{T}{N} model.
An oracle has access to and modifies the global protocol state via the global PROMELLA variables.
The attacker does not have access to the global state in the \CGKAmod model, and can only interact with the global state via the oracles.

\hypertarget{corrupt}{%
\subsection{Corrupt}\label{corrupt}}

A query of \Oracle{corrupt}{ID_n} within the \CGKAmod{P}{T}{N} model encoding performs a sequence of operations detailed in Figure \ref{fig:Oracle-Corrupt} which fulfills the oracle's semantics.
First the oracle encoding updates the attacker's knowledgebase via the \texttt{attacker\_learn\_leaf} and \texttt{attacker\_amend\_knowledge} interface methods for the protocol \texttt{P}.
The knowledge upadte may be iterative if the corrupted user has held onto secret cryptographic material from previous epoch.
Once all requisite information is transmitted from the oracle to the attacker, the oracle marks \(\mathtt{ID_n}\) as \texttt{unsafe}.
Lastly the oracle prompts the attacker to declare if their knowledgebase includes one or more \Abrev{LBBT} root node secrets for any epoch.

\begin{figure}[h!]
  \centering
  \caption{\label{fig:Oracle-Corrupt}\CGKAmod{}{}{} --- \Oracle{corr}{} encoding.}
\begin{verbatim}
inline corrupt ( memberID )
{
    targetID = memberID;

    // Learn the secret material of the user in their current epoch...
    // plus any additional epochs they have hoarded secrets from.
    unsigned lowerBound : BITS_EPOCH,
             upperBound : BITS_EPOCH;
    d_step
    {
        lowerBound = epoch;
        upperBound = epoch;
        unsigned savedSince : BITS_EPOCH = hoarding[memberID];
        if
        :: savedSince != NEVER -> lowerBound = savedSince
        :: else
        fi
    };

move_corrupt: skip;
    printf ( "Corrupting from: %d -- %d\n", lowerBound, upperBound );

    // For each epoch which the member has secrets
    // (this implies that the user was a member)
    // Then the attacker learns the secrets on the direct path
    // between the member and the root node on the LBBT.
    unsigned peek : BITS_EPOCH;
    for ( peek : lowerBound .. upperBound )
    {
        if
        :: !(membership[memberID]) -> skip
        :: else -> atomic
            {
                attacker_learn_leaf      ( peek, memberID );
                attacker_amend_knowledge ( peek );
            }
        fi
    };
    unsafe[memberID] = true;
    unsafe[memberID] = true;
    attacker_check_knowledge ( epoch );
}
\end{verbatim}
\end{figure}

\hypertarget{hoard}{%
\subsection{Hoard}\label{hoard}}

A query of \Oracle{hoard}{ID_n} within the \CGKAmod{P}{T}{N} model encoding simply marks that \(\mathtt{ID_n}\) will not delete cryptographic secrets starting from the current epoch, as shown in Figure \ref{fig:Oracle-Hoard}.

\begin{figure}[h!]
  \centering
  \caption{\label{fig:Oracle-Hoard}\CGKAmod{}{}{} --- \Oracle{no-del}{} encoding.}
\begin{verbatim}
inline hoard ( memberID )
{
    targetID = memberID;
move_hoard: skip;
    hoarding[memberID] = epoch;
}
\end{verbatim}
\end{figure}


\hypertarget{reveal}{%
\subsection{Reveal}\label{reveal}}

Querying \Oracle{reveal}{} updates the attacker's knowledgebase via the \texttt{attacker\_learn\_root} interface method as shown in Figure \ref{fig:Oracle-Reveal}.

\begin{figure}[h!]
  \centering
  \caption{\label{fig:Oracle-Reveal}\CGKAmod{}{}{} --- \Oracle{reveal}{} encoding.}
\begin{verbatim}
inline reveal ( )
{
move_reveal: skip;
    d_step {
        challenge[epoch] = true;
        attacker_learn_root ( epoch );
    }
}
\end{verbatim}
\end{figure}


\hypertarget{insert}{%
\subsection{Insert}\label{insert}}

A query of \Oracle{reveal}{ID_m,\, ID_n} performs the epoch progression as displayed in Figure \ref{fig:Oracle-Insert}.
First the oracle establishes \(\mathtt{ID_m}\) as \texttt{originID} and \(\mathtt{ID_n}\) as \texttt{targetID}.
Then the oracle calls the abstract epoch advancement method \texttt{messaging\_move} which handles message passing and global state updates.

\begin{figure}[h!]
  \centering
  \caption{\label{fig:Oracle-Insert}\CGKAmod{}{}{} --- \Oracle{add-user}{} encoding.}
\begin{verbatim}
inline insert_member ( memberID, inviteeID )
{
    d_step
    {
        originID =  memberID;
        targetID = inviteeID;
    };

move_insert: skip;
    messaging_move ( epoch + 1, memberID, inviteeID, NONE )
}
\end{verbatim}
\end{figure}


\hypertarget{remove}{%
\subsection{Remove}\label{remove}}

A query of \Oracle{reveal}{ID_m,\, ID_n} is displayed in Figure \ref{fig:Oracle-Remove}.
First the oracle establishes \(\mathtt{ID_m}\) as \texttt{originID} and \(\mathtt{ID_n}\) as \texttt{targetID}.
Next, the oracle conditionally decrements the \texttt{unsafeIDs} counter and ensures that \(\mathtt{unsafe[ID_n]}\) is false.
Finally the oracle calls the abstract epoch advancement method \texttt{messaging\_move} which handles message passing and global state updates.

\begin{figure}[h!]
  \centering
  \caption{\label{fig:Oracle-Remove}\CGKAmod{}{}{} --- \Oracle{remove-user}{} encoding.}
\begin{verbatim}
inline remove_member ( memberID, evicteeID )
{
    d_step
    {
        originID =  memberID;
        targetID = evicteeID;
    };

move_remove: skip;
    d_step
    {
        if
        :: unsafe[evicteeID] -> unsafeIDs--
        :: else
        fi
        unsafe[evicteeID] = false;
    };
    messaging_move ( epoch + 1, memberID, NONE, evicteeID )
}
\end{verbatim}
\end{figure}


\hypertarget{update}{%
\subsection{Update}\label{update}}

A query of \Oracle{reveal}{ID_n} is displayed in Figure \ref{fig:Oracle-Update}.
First the oracle establishes \(\mathtt{ID_n}\) as \texttt{originID}.
Next, the oracle conditionally decrements the \texttt{unsafeIDs} counter and ensures that \(\mathtt{unsafe[ID_m]}\) is false.
Finally the oracle calls the abstract epoch advancement method \texttt{messaging\_move} which handles message passing and global state updates.

\begin{figure}[h!]
  \centering
  \caption{\label{fig:Oracle-Update}\CGKAmod{}{}{} --- \Oracle{send-update}{} encoding.}
\begin{verbatim}
inline oblige_update ( memberID )
{
    d_step
    {
        originID = memberID;
        targetID = NONE;
    };

move_update: skip;
    d_step
    {
        if
        :: unsafe[memberID] -> unsafeIDs--
        :: else
        fi
        unsafe[memberID] = false;
    };
    messaging_move ( epoch + 1, memberID, NONE, NONE )
}
\end{verbatim}
\end{figure}


\hypertarget{sec:LTL-security}{%
\section{Security}\label{sec:LTL-security}}

Using the global variables and state labels within the encoding of \CGKAmod{N}{T}{N}, we can construct \Abrev{LTL} predicates for use during model verification.
Representing the \Abrev{FSU} and \Abrev{PCS} security guarantees will be the primary focus.
An additional predicate checking for model termination is included as a methodology confidence check.


\hypertarget{hlt-as-ltl}{%
\subsection{Termination as LTL}\label{hlt-as-ltl}}

\begin{LTL}[\,\LTLPredicate{HLT}\,]
    $$
    \Diamond \texttt{CGKA@end\_of\_game}
    $$
\end{LTL}

We consider the \Abrev{LTL} predicate \LTLPredicate{HLT}, which indicates that the \CGKAmod{P}{T}{N} model always terminates.
To support this verification, a state label \texttt{end\_of\_game} has been included in the PROMELA model indicating the final state of the \CGKAsec. 
The model has a single control process for the \CGKAsec named \texttt{CGKA}.
An \Abrev{LTL} atom \texttt{CGKA@end\_of\_game} is true if an only if the process \texttt{CGKA} is at state \texttt{end\_of\_game}.
With these syntactic definitions, the verification of \(\CGKAmod{P}{T}{N} \models \LTLPredicate{HLT} \) is successful if and only if every possible execution of the model \CGKAmod{}{}{}, the program reaches the state \texttt{CGKA@start\_of\_epoch}.


\hypertarget{pcs-as-ltl}{%
\subsection{\Abrev{PCS} as LTL}\label{pcs-as-ltl}}

\begin{LTL}[\,\LTLPredicate{PCS}\,]
    $$
    \Box \Big(\, ( \texttt{CGKA@start\_of\_epoch} \land \texttt{unsafeIDs} = 0 ) \implies \neg \texttt{learnedKey[epoch]} \Big)
    $$
\end{LTL}


\hypertarget{fsu-as-ltl}{%
\subsection{\Abrev{FSU} as LTL}\label{fsu-as-ltl}}

\begin{LTL}[\;Never-Trivial\;]
    $$
    \Box \left( \texttt{CGKA@move\_corrupt} \implies \texttt{hoarding[targetID]} = \texttt{NEVER} \right)
    $$
\end{LTL}

\begin{LTL}[\;FSU-Epoch(\,\textnormal{\normalfont $t \in T$}\,)\;]
    \begin{equation*}
    \begin{split}
    \Diamond ( & \texttt{CGKA@move\_start\_of\_epoch} \land \texttt{epoch} = t + 1 \land \neg \texttt{learnedKey[$t$]} ) \\
    & \implies ( \neg \texttt{learnedKey[$t$]} ) \,\;{\mathcal {U}}\;\, \texttt{CGKA@end\_of\_game}
    \end{split}
    \end{equation*}
\end{LTL}

\begin{LTL}[\,\LTLPredicate{FSU}\,]
    $$
    \textbf{Never-Trivial} \implies \bigwedge\limits_{t=0}^{T-1} \;\,\textbf{FSU-Epoch}(t)
    $$
\end{LTL}
